{"version":3,"file":"nipkow-sdk.cjs.production.min.js","sources":["../src/constants/network.ts","../src/constants/derivationPaths.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/httpClient.ts","../src/Allegory.ts","../src/Persist.ts","../src/AddressAPI.ts","../src/TransactionAPI.ts","../src/ChainAPI.ts","../src/Utils.ts","../src/Wallet.ts","../src/Allpay.ts","../src/AuthAPI.ts","../src/BlockAPI.ts","../src/MerkleBranchAPI.ts","../src/ScriptHashAPI.ts","../src/UserAPI.ts"],"sourcesContent":["export default {\n  BITCOIN_SV: {\n    bip32: {\n      public: 0x0488b21e,\n      private: 0x0488ade4,\n    },\n    bech32: '',\n    messagePrefix: 'unused',\n    pubKeyHash: 0x00,\n    scriptHash: 0x05,\n    wif: 0x80,\n  },\n  BITCOIN_SV_REGTEST: {\n    bip32: {\n      public: 0x043587cf,\n      private: 0x04358394,\n    },\n    bech32: 'bcrt',\n    messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n    pubKeyHash: 0x6f,\n    scriptHash: 0xc4,\n    wif: 0xef,\n    p2wpkh: {\n      baseNetwork: 'regtest',\n      messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n      bech32: 'bcrt',\n      bip32: {\n        public: 0x045f1cf6,\n        private: 0x045f18bc,\n      },\n      pubKeyHash: 0x6f,\n      scriptHash: 0xc4,\n      wif: 0xef,\n    },\n    p2wpkhInP2sh: {\n      baseNetwork: 'regtest',\n      messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n      bech32: 'bcrt',\n      bip32: {\n        public: 0x044a5262,\n        private: 0x044a4e28,\n      },\n      pubKeyHash: 0x6f,\n      scriptHash: 0xc4,\n      wif: 0xef,\n    },\n    p2wsh: {\n      baseNetwork: 'regtest',\n      messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n      bech32: 'bcrt',\n      bip32: {\n        public: 0x02575483,\n        private: 0x02575048,\n      },\n      pubKeyHash: 0x6f,\n      scriptHash: 0xc4,\n      wif: 0xef,\n    },\n    p2wshInP2sh: {\n      baseNetwork: 'regtest',\n      messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n      bech32: 'bcrt',\n      bip32: {\n        public: 0x024289ef,\n        private: 0x024285b5,\n      },\n      pubKeyHash: 0x6f,\n      scriptHash: 0xc4,\n      wif: 0xef,\n    },\n  },\n  BITCOIN_SV_TESTNET: {\n    bip32: {\n      public: 0x043587cf,\n      private: 0x04358394,\n    },\n    bech32: 'tb',\n    messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n    pubKeyHash: 0x6f,\n    scriptHash: 0xc4,\n    wif: 0xef,\n    p2wpkh: {\n      baseNetwork: 'testnet',\n      messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n      bech32: 'tb',\n      bip32: {\n        public: 0x045f1cf6,\n        private: 0x045f18bc,\n      },\n      pubKeyHash: 0x6f,\n      scriptHash: 0xc4,\n      wif: 0xef,\n    },\n    p2wsh: {\n      baseNetwork: 'testnet',\n      messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n      bech32: 'tb',\n      bip32: {\n        public: 0x02575483,\n        private: 0x02575048,\n      },\n      pubKeyHash: 0x6f,\n      scriptHash: 0xc4,\n      wif: 0xef,\n    },\n    p2wpkhInP2sh: {\n      baseNetwork: 'testnet',\n      messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n      bech32: 'tb',\n      bip32: {\n        public: 0x044a5262,\n        private: 0x044a4e28,\n      },\n      pubKeyHash: 0x6f,\n      scriptHash: 0xc4,\n      wif: 0xef,\n    },\n    p2wshInP2sh: {\n      baseNetwork: 'testnet',\n      messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n      bech32: 'tb',\n      bip32: {\n        public: 0x024289ef,\n        private: 0x024285b5,\n      },\n      pubKeyHash: 0x6f,\n      scriptHash: 0xc4,\n      wif: 0xef,\n    },\n  },\n};\n","export default {\n  BITCOIN_SV: {\n    BIP32: {\n      derivationPath: 'm/0',\n    },\n    BIP44: {\n      purpose: 44,\n      coin: 236,\n      account: 0,\n      change: 0,\n      derivationPath: \"m/44'/236'/0'/0\",\n      nUTXODerivationPath: \"m/44'/236'/1'/0\",\n    },\n  },\n  BITCOIN_SV_TESTNET: {\n    BIP32: {\n      derivationPath: 'm/0',\n    },\n    BIP44: {\n      purpose: 44,\n      coin: 1,\n      account: 0,\n      change: 0,\n      derivationPath: 'm/44/1/0/0',\n      nUTXODerivationPath: 'm/44/1/1/0',\n    },\n  },\n  BITCOIN_SV_REGTEST: {\n    BIP32: {\n      derivationPath: 'm/0',\n    },\n    BIP44: {\n      purpose: 44,\n      coin: 1,\n      account: 0,\n      change: 0,\n      derivationPath: 'm/44/1/0/0',\n      nUTXODerivationPath: 'm/44/1/1/0',\n    },\n  },\n};\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import https from 'https';\nimport axios, { AxiosInstance, AxiosRequestConfig } from 'axios';\n\nlet httpReq: AxiosInstance;\n\nexport const init = (host: string, port: number) => {\n  httpReq = axios.create({\n    baseURL: `https://${host}:${port}/v1`,\n    httpsAgent: new https.Agent({\n      rejectUnauthorized: false,\n    }),\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n  httpReq.interceptors.request.use(\n    (config) => {\n      const token = localStorage.getItem('sessionKey');\n      config.headers.Authorization = token ? `Bearer ${token}` : '';\n      return config;\n    },\n    (error) => {\n      console.log(error);\n      return Promise.reject(error);\n    }\n  );\n  httpReq.interceptors.response.use(\n    (response) => {\n      return response;\n    },\n    async (error) => {\n      if (error && error.response && error.response.status === 403) {\n        try {\n          const userName: string = localStorage.getItem('userName')!;\n          const password: string = localStorage.getItem('password')!;\n          const {\n            data: {\n              auth: { sessionKey },\n            },\n          } = await post('auth', { userName, password });\n          if (sessionKey) {\n            localStorage.setItem('sessionKey', sessionKey);\n            Promise.resolve();\n          } else {\n            throw new Error('Invalid sessionKey');\n          }\n        } catch (error) {\n          return Promise.reject(error);\n        }\n      } else {\n        return new Promise((resolve, reject) => {\n          reject(error);\n        });\n      }\n    }\n  );\n};\n\nexport const get = async (url: string, config?: AxiosRequestConfig) => {\n  try {\n    const response = await httpReq.get(url, config);\n    return response;\n  } catch (error) {\n    throw error;\n  }\n};\n\nexport const post = async (\n  url: string,\n  data?: any,\n  config?: AxiosRequestConfig\n) => {\n  try {\n    const response = await httpReq.post(url, data, config);\n    return response;\n  } catch (error) {\n    throw error;\n  }\n};\n\nexport const put = async (\n  url: string,\n  data?: any,\n  config?: AxiosRequestConfig\n) => {\n  try {\n    const response = await httpReq.put(url, data, config);\n    return response;\n  } catch (error) {\n    throw error;\n  }\n};\n\nexport const deleteR = async (url: string, config?: AxiosRequestConfig) => {\n  try {\n    const response = await httpReq.delete(url, config);\n    return response;\n  } catch (error) {\n    throw error;\n  }\n};\n","import CBOR from 'cbor-js';\n\nclass Allegory {\n  private _version!: number;\n  public get version(): number {\n    return this._version;\n  }\n  public set version(value: number) {\n    this._version = value;\n  }\n  private _name!: number[];\n  public get name(): number[] {\n    return this._name;\n  }\n  public set name(value: number[]) {\n    this._name = value;\n  }\n  private _action!: Action;\n  public get action(): Action {\n    return this._action;\n  }\n  public set action(value: Action) {\n    this._action = value;\n  }\n}\n\ntype Action = ProducerAction | OwnerAction;\n\nexport class ProducerAction {\n  private _producerInput!: Index;\n  public get producerInput(): Index {\n    return this._producerInput;\n  }\n  public set producerInput(value: Index) {\n    this._producerInput = value;\n  }\n  private _producerOutput!: ProducerOutput;\n  public get producerOutput(): ProducerOutput {\n    return this._producerOutput;\n  }\n  public set producerOutput(value: ProducerOutput) {\n    this._producerOutput = value;\n  }\n  private _pOwnerOutput?: OwnerOutput;\n  public get pOwnerOutput(): OwnerOutput {\n    return this._pOwnerOutput!;\n  }\n  public set pOwnerOutput(value: OwnerOutput) {\n    this._pOwnerOutput = value;\n  }\n  private _extensions!: Extension[];\n  public get extensions(): Extension[] {\n    return this._extensions;\n  }\n  public set extensions(value: Extension[]) {\n    this._extensions = value;\n  }\n}\n\nexport class OwnerAction {\n  private _ownerInput!: Index;\n  public get ownerInput(): Index {\n    return this._ownerInput;\n  }\n  public set ownerInput(value: Index) {\n    this._ownerInput = value;\n  }\n  private _ownerOutput!: OwnerOutput;\n  public get ownerOutput(): OwnerOutput {\n    return this._ownerOutput;\n  }\n  public set ownerOutput(value: OwnerOutput) {\n    this._ownerOutput = value;\n  }\n  private _oProxyProviders!: ProxyProvider[];\n  public get oProxyProviders(): ProxyProvider[] {\n    return this._oProxyProviders;\n  }\n  public set oProxyProviders(value: ProxyProvider[]) {\n    this._oProxyProviders = value;\n  }\n}\n\nclass Index {\n  private _index!: number;\n  public get index(): number {\n    return this._index;\n  }\n  public set index(value: number) {\n    this._index = value;\n  }\n}\n\nclass ProducerOutput {\n  private _producer!: Index;\n  public get producer(): Index {\n    return this._producer;\n  }\n  public set producer(value: Index) {\n    this._producer = value;\n  }\n  private _pVendorEndpoint?: Endpoint;\n  public get pVendorEndpoint(): Endpoint {\n    return this._pVendorEndpoint!;\n  }\n  public set pVendorEndpoint(value: Endpoint) {\n    this._pVendorEndpoint = value;\n  }\n}\n\nclass OwnerOutput {\n  private _owner!: Index;\n  public get owner(): Index {\n    return this._owner;\n  }\n  public set owner(value: Index) {\n    this._owner = value;\n  }\n  private _oVendorEndpoint?: Endpoint;\n  public get oVendorEndpoint(): Endpoint {\n    return this._oVendorEndpoint!;\n  }\n  public set oVendorEndpoint(value: Endpoint) {\n    this._oVendorEndpoint = value;\n  }\n}\n\nexport type Extension = OwnerExtension | ProducerExtension;\n\nexport class OwnerExtension {\n  private _ownerOutputEx!: OwnerOutput;\n  public get ownerOutputEx(): OwnerOutput {\n    return this._ownerOutputEx;\n  }\n  public set ownerOutputEx(value: OwnerOutput) {\n    this._ownerOutputEx = value;\n  }\n  private _codePoint!: number;\n  public get codePoint(): number {\n    return this._codePoint;\n  }\n  public set codePoint(value: number) {\n    this._codePoint = value;\n  }\n}\n\nexport class ProducerExtension {\n  private _producerOutputEx!: ProducerOutput;\n  public get producerOutputEx(): ProducerOutput {\n    return this._producerOutputEx;\n  }\n  public set producerOutputEx(value: ProducerOutput) {\n    this._producerOutputEx = value;\n  }\n  private _codePoint!: number;\n  public get codePoint(): number {\n    return this._codePoint;\n  }\n  public set codePoint(value: number) {\n    this._codePoint = value;\n  }\n}\n\nclass Endpoint {\n  private _protocol!: string;\n  public get protocol(): string {\n    return this._protocol;\n  }\n  public set protocol(value: string) {\n    this._protocol = value;\n  }\n  private _uri!: string;\n  public get uri(): string {\n    return this._uri;\n  }\n  public set uri(value: string) {\n    this._uri = value;\n  }\n}\n\nclass ProxyProvider {\n  private _service!: string;\n  public get service(): string {\n    return this._service;\n  }\n  public set service(value: string) {\n    this._service = value;\n  }\n  private _mode!: string;\n  public get mode(): string {\n    return this._mode;\n  }\n  public set mode(value: string) {\n    this._mode = value;\n  }\n  private _endpoint!: Endpoint;\n  public get endpoint(): Endpoint {\n    return this._endpoint;\n  }\n  public set endpoint(value: Endpoint) {\n    this._endpoint = value;\n  }\n  private _registration!: Registration;\n  public get registration(): Registration {\n    return this._registration;\n  }\n  public set registration(value: Registration) {\n    this._registration = value;\n  }\n}\n\nclass Registration {\n  private _addressCommitment!: string;\n  public get addressCommitment(): string {\n    return this._addressCommitment;\n  }\n  public set addressCommitment(value: string) {\n    this._addressCommitment = value;\n  }\n  private _utxoCommitment!: string;\n  public get utxoCommitment(): string {\n    return this._utxoCommitment;\n  }\n  public set utxoCommitment(value: string) {\n    this._utxoCommitment = value;\n  }\n  private _signature!: string;\n  public get signature(): string {\n    return this._signature;\n  }\n  public set signature(value: string) {\n    this._signature = value;\n  }\n  private _expiry!: number;\n  public get expiry(): number {\n    return this._expiry;\n  }\n  public set expiry(value: number) {\n    this._expiry = value;\n  }\n}\n\nexport function getAllegoryType(decodedCBOR: any): Allegory {\n  const allegory = new Allegory();\n  if (decodedCBOR.length >= 2) {\n    allegory.version = decodedCBOR[1];\n    allegory.name = decodedCBOR[2];\n    if (decodedCBOR[3].length === 4) {\n      allegory.action = _getOwnerAction(decodedCBOR[3]);\n    }\n    if (decodedCBOR[3].length === 5) {\n      allegory.action = _getProducerAction(decodedCBOR[3]);\n    }\n  }\n  return allegory;\n}\n\nfunction _getOwnerAction(data: any): OwnerAction {\n  const ownerAction = new OwnerAction();\n  ownerAction.ownerInput = _getIndex(data[1]);\n  ownerAction.ownerOutput = _getOwnerOutput(data[2]);\n  ownerAction.oProxyProviders = _getProxyProviders(data[3]);\n  return ownerAction;\n}\n\nfunction _getIndex(data: any[]) {\n  const index = new Index();\n  index.index = data[1];\n  return index;\n}\n\nfunction _getOwnerOutput(data: any[]) {\n  const ownerOutput = new OwnerOutput();\n  ownerOutput.owner = _getIndex(data[1]);\n  ownerOutput.oVendorEndpoint = _getVendorEndpoint(data[2]);\n  return ownerOutput;\n}\n\nfunction _getVendorEndpoint(data: any[]) {\n  return _getEndPoint(data[0]);\n}\n\nfunction _getProxyProviders(datas: any[]) {\n  const proxyProviders: ProxyProvider[] = datas.map((data: any[]) => {\n    const proxyProvider = new ProxyProvider();\n    proxyProvider.service = data[1];\n    proxyProvider.mode = data[2];\n    proxyProvider.endpoint = _getEndPoint(data[3]);\n    proxyProvider.registration = _getRegistration(data[4]);\n    return proxyProvider;\n  });\n  return proxyProviders;\n}\n\nfunction _getRegistration(data: any[]) {\n  const registration = new Registration();\n  registration.addressCommitment = data[1];\n  registration.utxoCommitment = data[2];\n  registration.signature = data[3];\n  registration.expiry = data[4];\n  return registration;\n}\n\nfunction _getProducerAction(data: any): ProducerAction {\n  const producerAction = new ProducerAction();\n  producerAction.producerInput = _getIndex(data[1]);\n  producerAction.producerOutput = _getProducerOutput(data[2]);\n  if (data[3].length > 0) {\n    producerAction.pOwnerOutput = _getPOwnerOutput(data[3]);\n  }\n  producerAction.extensions = _getExtensions(data[4]);\n  return producerAction;\n}\n\nfunction _getProducerOutput(data: any[]) {\n  const producerOutput = new ProducerOutput();\n  producerOutput.producer = _getIndex(data[1]);\n  producerOutput.pVendorEndpoint = _getEndPoint(data[2][0]);\n  return producerOutput;\n}\n\nfunction _getPOwnerOutput(data: any[]) {\n  const ownerOutput = new OwnerOutput();\n  ownerOutput.owner = _getIndex(data[1]);\n  ownerOutput.oVendorEndpoint = _getVendorEndpoint(data[2]);\n  return ownerOutput;\n}\n\nfunction _getExtensions(datas: any[]) {\n  const extensions: Extension[] = datas.map((data: any[]) => {\n    if (data[0] === 0) {\n      return _getOwnerExtension(data);\n    } else {\n      return _getProducerExtension(data);\n    }\n  });\n  return extensions;\n}\n\nfunction _getOwnerExtension(data: any[]) {\n  const ownerExtension = new OwnerExtension();\n  ownerExtension.ownerOutputEx = _getOwnerOutput(data[1]);\n  ownerExtension.codePoint = data[2];\n  return ownerExtension;\n}\n\nfunction _getProducerExtension(data: any[]) {\n  const producerExtension = new ProducerExtension();\n  producerExtension.producerOutputEx = _getProducerOutput(data[1]);\n  producerExtension.codePoint = data[2];\n  return producerExtension;\n}\n\nfunction _getEndPoint(data: any[]) {\n  const endpoint = new Endpoint();\n  endpoint.protocol = data[1];\n  endpoint.uri = data[2];\n  return endpoint;\n}\n\nexport function removeOpReturn(data: string) {\n  const prefixRemoved = data.substring(36);\n  const opcode = parseInt(prefixRemoved.substring(0, 2), 16);\n  if (opcode <= 0x4b) {\n    return prefixRemoved.substring(2);\n    // remaining\n  } else if (opcode === 0x4c) {\n    return prefixRemoved.substring(4);\n    // take 2\n  } else if (opcode === 0x4d) {\n    return prefixRemoved.substring(6);\n    // take 4\n  } else if (opcode === 0x4e) {\n    return prefixRemoved.substring(10);\n    // take 8\n  } else if (opcode === 0x99) {\n    throw new Error('Incorrect data');\n  }\n  throw new Error('Incorrect data');\n}\n\nexport function decodeCBORData(data: string) {\n  const hexData = removeOpReturn(data);\n  const allegoryDataBuffer = Buffer.from(hexData, 'hex');\n  const allegoryDataArrayBuffer = allegoryDataBuffer.buffer.slice(\n    allegoryDataBuffer.byteOffset,\n    allegoryDataBuffer.byteOffset + allegoryDataBuffer.byteLength\n  );\n  try {\n    return CBOR.decode(allegoryDataArrayBuffer);\n  } catch (error) {\n    console.log(error);\n    throw error;\n  }\n}\n","import PouchDB from 'pouchdb-browser';\nimport MemoryAdapter from 'pouchdb-adapter-memory';\nimport pouchdbFind from 'pouchdb-find';\nimport CryptoJS from 'crypto-js';\nimport AES from 'crypto-js/aes';\n\nPouchDB.plugin(MemoryAdapter);\nPouchDB.plugin(pouchdbFind);\n\nlet profiles: any;\nlet db: any;\nlet credentials: any;\n\nexport const BIP32_EXTENDED_KEY = 'bip32ExtendedKey';\nexport const NUTXO_EXTENDED_KEY = 'nUTXOExtendedKey';\n\n/* Revisit all fn for try-catch error handling */\n\nconst get = async (db: any, key: string) => await db.get(key);\n\nconst set = async (db: any, key: string, value: any) => {\n  const doc: any = await db.get(key);\n  for (const prop in value) {\n    doc[prop] = value[prop];\n  }\n  await db.put(doc);\n};\n\nexport const init = async (dbName: string) => {\n  db = new PouchDB(`${dbName}`, {\n    revs_limit: 1,\n    auto_compaction: true,\n  });\n  credentials = new PouchDB('credentials', {\n    revs_limit: 1,\n    auto_compaction: true,\n    // adapter: 'memory',\n  });\n  await credentials.bulkDocs([\n    { _id: BIP32_EXTENDED_KEY, value: null },\n    { _id: NUTXO_EXTENDED_KEY, value: null },\n  ]);\n};\n\n/* Revisit required */\nexport const createProfile = async (\n  cryptedMnemonic: string,\n  profileName: string\n) => {\n  const newProfile = { cryptedMnemonic, name: profileName };\n  try {\n    const existingProfiles: any = await profiles.get('profiles');\n    if (\n      existingProfiles &&\n      existingProfiles.value &&\n      existingProfiles.value instanceof Array\n    ) {\n      existingProfiles.value = [...existingProfiles.value, newProfile];\n      await profiles.put(existingProfiles);\n    } else {\n      await profiles.put({\n        _id: 'profiles',\n        value: [newProfile],\n      });\n    }\n  } catch (error) {\n    await profiles.put({\n      _id: 'profiles',\n      value: [newProfile],\n    });\n  }\n};\n\n/* Revisit required */\nexport const updateProfile = async (\n  currentProfileName: string,\n  newProfileName: string\n) => {\n  try {\n    const existingProfiles: any = await profiles.get('profiles', {\n      revs: true,\n    });\n\n    const profileIndex = existingProfiles.value.findIndex(\n      (profile: any) => profile.name === currentProfileName\n    );\n\n    const profilesArray = existingProfiles.value;\n\n    profilesArray[profileIndex].name = newProfileName;\n\n    await profiles.put({\n      _id: 'profiles',\n      _rev: existingProfiles._rev,\n      value: profilesArray,\n    });\n  } catch (error) {\n    throw error;\n  }\n};\n\n/* Revisit required */\nexport const getProfiles = async () => {\n  try {\n    profiles = new PouchDB('Profiles', {\n      revs_limit: 1,\n      auto_compaction: true,\n    });\n    const existingProfiles: any = await profiles.get('profiles');\n    if (\n      existingProfiles &&\n      existingProfiles.value &&\n      existingProfiles.value instanceof Array\n    ) {\n      const profileNames = existingProfiles.value.map(\n        (existingProfile: any) => existingProfile\n      );\n      return profileNames;\n    } else {\n      return [];\n    }\n  } catch (error) {\n    return [];\n  }\n};\n\n/* Revisit required */\nexport const login = async (profile: string, password: string) => {\n  const existingProfiles = await getProfiles();\n  const selectedProfile = existingProfiles.find(\n    (existingProfile: { name: string }) => existingProfile.name === profile\n  );\n  if (selectedProfile) {\n    const bip39Mnemonic = AES.decrypt(\n      selectedProfile.cryptedMnemonic,\n      password\n    ).toString(CryptoJS.enc.Utf8);\n    if (bip39Mnemonic) {\n      return bip39Mnemonic;\n    } else {\n      throw new Error('Login error');\n    }\n  } else {\n    throw new Error(\"Account Doesn't exist\");\n  }\n};\n\nexport const getBip32ExtendedKey = async () => {\n  const bip32ExtendedKeyDoc: any = await get(credentials, BIP32_EXTENDED_KEY);\n  return bip32ExtendedKeyDoc.value;\n};\n\nexport const setBip32ExtendedKey = async (value: any) =>\n  await set(credentials, BIP32_EXTENDED_KEY, { value });\n\nexport const getNUTXOExtendedKey = async () => {\n  const nUTXOExtendedKeyDoc: any = await get(credentials, NUTXO_EXTENDED_KEY);\n  return nUTXOExtendedKeyDoc.value;\n};\n\nexport const setNUTXOExtendedKey = async (value: any) =>\n  await set(credentials, NUTXO_EXTENDED_KEY, { value });\n\nexport const getNUTXODerivedKeys = async () => {\n  const response = await db.allDocs({\n    include_docs: true,\n    startkey: 'nUTXOKey',\n    endkey: 'nUTXOKey\\ufff0',\n  });\n  if (response && response.rows.length > 0) {\n    const existingNUTXODerivedKeys = response.rows.map(\n      (row: { doc: any }) => row.doc\n    );\n    return { existingNUTXODerivedKeys };\n  } else {\n    return { existingNUTXODerivedKeys: [] };\n  }\n};\n\nexport const upsertNUTXODerivedKeys = async (keys: any) => {\n  if (keys.length > 0) {\n    const { existingNUTXODerivedKeys } = await getNUTXODerivedKeys();\n    let keyId = existingNUTXODerivedKeys.length - 1;\n    const docs = keys.map((key: any, index: number) => {\n      if (!key._id) {\n        keyId = keyId + 1;\n      }\n      return {\n        ...key,\n        _id: key._id ? key._id : `nUTXOKey-${String(keyId).padStart(20, '0')}`,\n      };\n    });\n    await db.bulkDocs(docs);\n  }\n};\n\nexport const getDerivedKeys = async () => {\n  const response = await db.allDocs({\n    include_docs: true,\n    startkey: 'key',\n    endkey: 'key\\ufff0',\n  });\n  if (response && response.rows.length > 0) {\n    const existingDerivedKeys = response.rows.map(\n      (row: { doc: any }) => row.doc\n    );\n    return { existingDerivedKeys };\n  } else {\n    return { existingDerivedKeys: [] };\n  }\n};\n\nexport const upsertDerivedKeys = async (keys: any) => {\n  if (keys.length > 0) {\n    const { existingDerivedKeys } = await getDerivedKeys();\n    let keyId = existingDerivedKeys.length - 1;\n    const docs = keys.map((key: any, index: number) => {\n      if (!key._id) {\n        keyId = keyId + 1;\n      }\n      return {\n        ...key,\n        _id: key._id ? key._id : `key-${String(keyId).padStart(20, '0')}`,\n      };\n    });\n    await db.bulkDocs(docs);\n  }\n};\n\nexport const getOutputs = async (options?: {\n  startkey?: string;\n  limit?: number;\n  diff?: boolean;\n}) => {\n  const response = await db.allDocs({\n    include_docs: true,\n    ...options,\n    startkey: options?.startkey || 'output',\n    endkey: 'output\\ufff0',\n    skip: options?.startkey ? 1 : false,\n  });\n  if (response && response.rows.length > 0) {\n    const nextOutputsCursor = response.rows[response.rows.length - 1].id;\n    const outputs = response.rows.map((row: { doc: any }) => row.doc);\n    return { nextOutputsCursor, outputs };\n  } else {\n    return { nextOutputsCursor: null, outputs: [] };\n  }\n};\n\nexport const markOutputAsUnspent = async (\n  inputs: [\n    {\n      outputTxHash: string;\n      outputIndex: number;\n    }\n  ]\n) => {\n  const markAsUnspentOutputs: any[] = [];\n  for (let index = 0; index < inputs.length; index++) {\n    const input = inputs[index];\n    await db.createIndex({\n      index: { fields: ['outputTxHash', 'outputIndex'] },\n    });\n    const outputDoc = await db.find({\n      selector: {\n        outputTxHash: { $eq: input.outputTxHash },\n        outputIndex: { $eq: input.outputIndex },\n      },\n    });\n    if (outputDoc.docs.length > 0) {\n      const unspentOutputs = outputDoc.docs.map((output: any) => {\n        return {\n          ...output,\n          isSpent: false,\n        };\n      });\n      markAsUnspentOutputs.push(...unspentOutputs);\n    }\n  }\n  await db.bulkDocs(markAsUnspentOutputs);\n};\n\nexport const upsertOutputs = async (outputs: any) => {\n  if (outputs.length > 0) {\n    const { outputs: existingOutputs } = await getOutputs();\n\n    if (existingOutputs.length > 0) {\n    } else {\n    }\n    let outputId = existingOutputs.length - 1;\n    const docs = outputs.map((output: any, index: number) => {\n      if (!output._id) {\n        outputId = outputId + 1;\n      }\n      return {\n        ...output,\n        isSpent: output.isSpent\n          ? output.isSpent\n          : output.spendInfo\n          ? true\n          : false,\n        _id: output._id\n          ? output._id\n          : `output-${String(outputId).padStart(20, '0')}`,\n      };\n    });\n    await db.bulkDocs(docs);\n  }\n};\n\n/* _rev change case */\nexport const updateOutputs = async (outputs: any) => {\n  const updateDoc = [];\n  for (let index = 0; index < outputs.length; index++) {\n    const element = outputs[index];\n    const outputDoc = await db.get(element._id);\n    updateDoc.push({ ...element, _rev: outputDoc._rev });\n  }\n  try {\n    const results = await db.bulkDocs(updateDoc);\n    results.forEach((result: { error: any }) => {\n      if (result.error) {\n        throw new Error('Error in updating outputs');\n      }\n    });\n  } catch (error) {\n    throw error;\n  }\n};\n\n/* No _id, _rev change case */\nexport const deleteOutputs = async (\n  outputs: [\n    {\n      outputTxHash: string;\n      outputIndex: number;\n    }\n  ]\n) => {\n  const deletedOutputs: any[] = [];\n  for (let index = 0; index < outputs.length; index++) {\n    const output = outputs[index];\n    await db.createIndex({\n      index: { fields: ['outputTxHash', 'outputIndex'] },\n    });\n    const outputDoc = await db.find({\n      selector: {\n        outputTxHash: { $eq: output.outputTxHash },\n        outputIndex: { $eq: output.outputIndex },\n      },\n    });\n    if (outputDoc.docs.length > 0) {\n      const deletedOutput = outputDoc.docs.map((output: any) => {\n        return {\n          ...output,\n          _deleted: true,\n        };\n      });\n      deletedOutputs.push(...deletedOutput);\n    }\n  }\n  await db.bulkDocs(deletedOutputs);\n};\n\nexport const isInOutputs = async (output: {\n  outputTxHash: string;\n  outputIndex: number;\n}) => {\n  await db.createIndex({\n    index: { fields: ['outputTxHash', 'outputIndex'] },\n  });\n  const outputDoc = await db.find({\n    selector: {\n      outputTxHash: { $eq: output.outputTxHash },\n      outputIndex: { $eq: output.outputIndex },\n    },\n  });\n  if (outputDoc.docs.length > 0) return true;\n  return false;\n};\n\nexport const getTransactions = async (options?: {\n  startkey?: string;\n  limit?: number;\n  diff?: boolean;\n}) => {\n  const response = await db.allDocs({\n    include_docs: true,\n    ...options,\n    descending: true,\n    endkey: 'transaction',\n    // endkey: 'transaction\\ufff0',\n    startkey: options?.startkey || 'transaction\\ufff0',\n    skip: options?.startkey ? 1 : false,\n  });\n  if (response && response.rows.length > 0) {\n    let nextTransactionCursor;\n    if (response.rows.length === options?.limit) {\n      nextTransactionCursor = response.rows[response.rows.length - 1].id;\n    } else {\n      nextTransactionCursor = null;\n    }\n    const transactions = response.rows.map((row: { doc: any }) => row.doc);\n    return { nextTransactionCursor, transactions };\n  } else {\n    return { nextTransactionCursor: null, transactions: [] };\n  }\n};\n\nexport const getTransactionsByConfirmations = async (options?: {\n  startkey?: string;\n  limit?: number;\n  diff?: boolean;\n}) => {\n  await db.createIndex({\n    index: { fields: ['confirmation'] },\n  });\n  const transactionDocs = await db.find({\n    selector: {\n      $and: [\n        { confirmation: { $lte: 10 } },\n        { confirmation: { $exists: true } },\n      ],\n    },\n  });\n  if (transactionDocs.docs.length > 0)\n    return { transactions: transactionDocs.docs };\n  return { transactions: [] };\n};\n\nexport const upsertTransactions = async (transactions: any[]) => {\n  if (transactions.length > 0) {\n    const { transactions: existingTransactions } = await getTransactions();\n    let txId = existingTransactions.length - 1;\n    const docs = transactions\n      .reverse()\n      .map((transaction: any, index: number) => {\n        if (!transaction._id) {\n          txId = txId + 1;\n        }\n        return {\n          ...transaction,\n          _id: transaction._id\n            ? transaction._id\n            : `transaction-${String(txId).padStart(20, '0')}`,\n        };\n      });\n    await db.bulkDocs(docs);\n  }\n};\n\n/* No _rev case */\nexport const deleteTransactions = async (transactions: any) => {\n  const updatedDoc = [];\n  for (let index = 0; index < transactions.length; index++) {\n    const transaction = transactions[index];\n    const transactionDoc = await db.get(transaction._id);\n    updatedDoc.push({\n      ...transaction,\n      _rev: transactionDoc._rev,\n      _deleted: true,\n    });\n  }\n  try {\n    const results = await db.bulkDocs(updatedDoc);\n    results.forEach((result: { error: any }) => {\n      if (result.error) {\n        throw new Error('Error in updating transactions');\n      }\n    });\n  } catch (error) {\n    throw error;\n  }\n};\n\nexport const markAddressesUsed = async (addresses: string[]) => {\n  if (addresses.length > 0) {\n    const { existingDerivedKeys } = await getDerivedKeys();\n    const matchedDerivedKeys = existingDerivedKeys.filter(\n      (key: any, index: number) => {\n        return addresses.includes(key.address);\n      }\n    );\n    const docs = matchedDerivedKeys.map((key: any, index: number) => {\n      return {\n        ...key,\n        isUsed: true,\n      };\n    });\n    await db.bulkDocs(docs);\n  }\n};\n\nexport const getUTXOs = async (options?: {\n  startkey?: string;\n  limit?: number;\n  diff?: boolean;\n}) => {\n  await db.createIndex({\n    index: { fields: ['isSpent', 'isNameOutpoint'] },\n  });\n  const outputDoc = await db.find({\n    selector: {\n      isSpent: { $eq: false },\n      isNameOutpoint: { $exists: false },\n    },\n  });\n  if (outputDoc.docs.length > 0) return { utxos: outputDoc.docs };\n  return { utxos: [] };\n};\n\nexport const getNUtxo = async (name: string) => {\n  await db.createIndex({\n    index: { fields: ['isSpent', 'name'] },\n  });\n  const outputDoc = await db.find({\n    selector: {\n      // isSpent: { $eq: false },\n      name: name,\n    },\n  });\n  if (outputDoc.docs.length > 0) return { nUTXOs: outputDoc.docs[0] };\n  return { nUTXOs: null };\n};\n\nexport const getUnregisteredName = async () => {\n  await db.createIndex({\n    index: { fields: ['isSpent', 'isNameOutpoint'] },\n  });\n  const outputDoc = await db.find({\n    selector: {\n      isSpent: { $eq: false },\n      isNameOutpoint: { $exists: true },\n    },\n  });\n  if (outputDoc.docs.length > 0) {\n    return { names: outputDoc.docs.map((doc: { name: string }) => doc.name) };\n  }\n  return { names: [] };\n};\n\nexport const destroy = async () => {\n  try {\n    await db.viewCleanup();\n    await credentials.destroy();\n    db = null;\n    credentials = null;\n    return true;\n  } catch (error) {\n    throw error;\n  }\n};\n","import { get } from './httpClient';\nimport Qs from 'qs';\n\nclass AddressAPI {\n  getOutputsByAddress = async (\n    address: string,\n    pagesize?: number,\n    cursor?: number\n  ) => {\n    try {\n      const { data } = await get(`address/${address}/outputs`, {\n        params: { pagesize, cursor },\n      });\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  getOutputsByAddresses = async (\n    addresses: string[],\n    pagesize?: number,\n    cursor?: number\n  ) => {\n    try {\n      const { data } = await get(`addresses/outputs`, {\n        params: {\n          address: addresses,\n          pagesize,\n          cursor,\n        },\n        paramsSerializer: (params) =>\n          Qs.stringify(params, { arrayFormat: 'repeat' }),\n      });\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  getUTXOsByAddress = async (\n    address: string,\n    pagesize?: number,\n    cursor?: number\n  ) => {\n    try {\n      const { data } = await get(`address/${address}/utxos`, {\n        params: { pagesize, cursor },\n      });\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  getUTXOsByAddresses = async (\n    addresses: string[],\n    pagesize?: number,\n    cursor?: number\n  ) => {\n    try {\n      const { data } = await get(`addresses/utxos`, {\n        params: {\n          address: addresses,\n          pagesize,\n          cursor,\n        },\n        paramsSerializer: (params) =>\n          Qs.stringify(params, { arrayFormat: 'repeat' }),\n      });\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n}\n\nexport const addressAPI = new AddressAPI();\n","import { get, post } from './httpClient';\nimport Qs from 'qs';\nclass TransactionAPI {\n  getTransactionByTxID = async (txId: string) => {\n    try {\n      const { data } = await get(`transaction/${txId}`);\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  getTransactionsByTxIDs = async (txIDs: string[]) => {\n    try {\n      const { data } = await get(`transactions`, {\n        params: {\n          id: txIDs,\n        },\n        paramsSerializer: (params) =>\n          Qs.stringify(params, { arrayFormat: 'repeat' }),\n      });\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  getRawTransactionByTxID = async (txID: string) => {\n    try {\n      const { data } = await get(`rawtransaction/${txID}`);\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  getRawTransactionsByTxIDs = async (txIDs: string[]) => {\n    try {\n      const { data } = await get(`rawtransactions`, {\n        params: {\n          id: txIDs,\n        },\n        paramsSerializer: (params) =>\n          Qs.stringify(params, { arrayFormat: 'repeat' }),\n      });\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  broadcastRawTransaction = async (hash: string) => {\n    try {\n      const { data } = await post(`relaytx`, {\n        rawTx: hash,\n      });\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  getSpendStatusByOutpoint = async (outpoint: string) => {\n    try {\n      const { data } = await get(`transaction/${outpoint}/index/0`);\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n}\n\nexport const transactionAPI = new TransactionAPI();\n","import { get } from './httpClient';\n\nclass ChainAPI {\n  getChainInfo = async () => {\n    try {\n      const { data } = await get(`chain/info`);\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  getBlockHeaders = async (startBlockHeight: number, pagesize?: number) => {\n    try {\n      const { data } = await get(`chain/headers`, {\n        params: {\n          startBlockHeight,\n          pagesize,\n        },\n      });\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n}\n\nexport const chainAPI = new ChainAPI();\n","import { bip32, Network, BIP32Interface } from 'bitcoinjs-lib';\nimport derivationPaths from './constants/derivationPaths';\nimport * as bip39 from 'bip39';\n\nclass Utils {\n  mnemonicToSeed = async (\n    bip39Mnemonic: string,\n    password?: string\n  ): Promise<Buffer> => {\n    return await bip39.mnemonicToSeed(bip39Mnemonic, password);\n  };\n\n  getSeedHex = (seed: Buffer) => {\n    return seed.toString('hex');\n  };\n\n  getBIP32RootKeyFromSeedHex = (\n    seed: string,\n    network?: Network\n  ): BIP32Interface => {\n    return bip32.fromBase58(seed, network);\n  };\n\n  getBIP32RootKeyBase58 = (bip32RootKey: BIP32Interface) => {\n    return bip32RootKey.toBase58();\n  };\n\n  getAccountExtendedPrivKey = (bip32ExtendedKey: BIP32Interface) => {\n    return bip32ExtendedKey.toBase58();\n  };\n\n  getAccountExtendedPubKey = (bip32ExtendedKey: any) => {\n    return bip32ExtendedKey.neutered().toBase58();\n  };\n\n  getDerivationPathAccount = (): string => {\n    const { purpose, coin, account } = derivationPaths.BITCOIN_SV.BIP44;\n    let path = 'm/';\n    path += purpose + \"'/\";\n    path += coin + \"'/\";\n    path += account + \"'/\";\n    return path;\n  };\n\n  getCodePoint(name: string) {\n    const nameCodePoints: number[] = [];\n    for (let i = 0; i < name.length; i++) {\n      nameCodePoints.push(name.codePointAt(i)!);\n    }\n    return nameCodePoints;\n  }\n\n  codePointToName = (codePoints: number[]) => {\n    if (codePoints && codePoints.length > 0) {\n      let name = '';\n      for (let i = 0; i < codePoints.length; i++) {\n        name += String.fromCodePoint(codePoints[i]);\n      }\n      return name;\n    }\n    return null;\n  };\n\n  // unique = (array, col) => [...new Set(array.map(() => col))];\n\n  // groupBy = (arr, col) => {\n  //   return arr.reduce((finalOutput, currVal) => {\n  //     if (!finalOutput[currVal[col]]) {\n  //       finalOutput[currVal[col]] = [];\n  //     }\n  //     finalOutput[currVal[col]].push(currVal);\n  //     return finalOutput;\n  //   }, {});\n  // };\n\n  // chunk = () => {};\n\n  arraysEqual(a: any[], b: any[]) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length !== b.length) return false;\n\n    // If you don't care about the order of the elements inside\n    // the array, you should sort both arrays here.\n    // Please note that calling sort on an array will modify that array.\n    // you might want to clone your array first.\n\n    for (var i = 0; i < a.length; ++i) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n\n  satoshiToBSV = (satoshi: number) => {\n    if (satoshi) return satoshi / 100000000;\n    return 0;\n  };\n}\n\nexport default new Utils();\n","import {\n  Network,\n  bip32,\n  ECPair,\n  networks,\n  payments,\n  Psbt,\n  Transaction,\n} from 'bitcoinjs-lib';\nimport AES from 'crypto-js/aes';\nimport coinSelect from 'coinselect';\nimport faker from 'faker';\nimport * as bip39 from 'bip39';\nimport * as _ from 'lodash';\nimport { differenceInMinutes } from 'date-fns';\nimport {\n  decodeCBORData,\n  getAllegoryType,\n  ProducerAction,\n  Extension,\n  OwnerExtension,\n  ProducerExtension,\n} from './Allegory';\nimport * as Persist from './Persist';\nimport derivationPaths from './constants/derivationPaths';\nimport network from './constants/network';\nimport { addressAPI } from './AddressAPI';\nimport { transactionAPI } from './TransactionAPI';\nimport { chainAPI } from './ChainAPI';\nimport utils from './Utils';\nimport { post } from './httpClient';\n\nclass Wallet {\n  async _initWallet(bip39Mnemonic: string, password?: string) {\n    const seed = this._mnemonicToSeedSync(bip39Mnemonic, password);\n    const bip32RootKey = this._getBIP32RootKeyFromSeed(\n      seed,\n      network.BITCOIN_SV_REGTEST\n    );\n    const bip32ExtendedKey = this._getBIP32ExtendedKey(\n      derivationPaths.BITCOIN_SV_REGTEST.BIP44.derivationPath,\n      bip32RootKey\n    );\n    const nUTXOExtendedKey = this._getBIP32ExtendedKey(\n      derivationPaths.BITCOIN_SV_REGTEST.BIP44.nUTXODerivationPath,\n      bip32RootKey\n    );\n    await Persist.setBip32ExtendedKey(bip32ExtendedKey);\n    await Persist.setNUTXOExtendedKey(nUTXOExtendedKey);\n\n    const { existingDerivedKeys } = await Persist.getDerivedKeys();\n    const countOfUnusedKeys = this._countOfUnusedKeys(existingDerivedKeys);\n    if (countOfUnusedKeys < 20) {\n      let lastKeyIndex = -1;\n      if (existingDerivedKeys.length > 0) {\n        lastKeyIndex = existingDerivedKeys[\n          existingDerivedKeys.length - 1\n        ].indexText\n          .split('/')\n          .pop();\n      }\n      const { derivedKeys: newDerivedKeys } = await this.generateDerivedKeys(\n        bip32ExtendedKey,\n        derivationPaths.BITCOIN_SV_REGTEST.BIP44.derivationPath,\n        Number(lastKeyIndex) + 1,\n        20 - countOfUnusedKeys,\n        false\n      );\n      await Persist.upsertDerivedKeys(newDerivedKeys);\n    }\n\n    const { existingNUTXODerivedKeys } = await Persist.getNUTXODerivedKeys();\n    const countOfUnusedNUTXOKeys = this._countOfUnusedKeys(\n      existingNUTXODerivedKeys\n    );\n    if (countOfUnusedNUTXOKeys < 20) {\n      let lastKeyIndex = -1;\n      if (existingNUTXODerivedKeys.length > 0) {\n        lastKeyIndex = existingNUTXODerivedKeys[\n          existingNUTXODerivedKeys.length - 1\n        ].indexText\n          .split('/')\n          .pop();\n      }\n      const { derivedKeys: newDerivedKeys } = await this.generateDerivedKeys(\n        nUTXOExtendedKey,\n        derivationPaths.BITCOIN_SV_REGTEST.BIP44.nUTXODerivationPath,\n        Number(lastKeyIndex) + 1,\n        20 - countOfUnusedNUTXOKeys,\n        false\n      );\n      await Persist.upsertNUTXODerivedKeys(newDerivedKeys);\n    }\n  }\n\n  _mnemonicToSeedSync(bip39Mnemonic: string, password?: string): Buffer {\n    return bip39.mnemonicToSeedSync(bip39Mnemonic, password);\n  }\n\n  _getBIP32RootKeyFromSeed(seed: Buffer, network?: Network): string {\n    return bip32.fromSeed(seed, network).toBase58();\n  }\n\n  _getBIP32ExtendedKey(path: string, bip32RootKey: string): string {\n    if (!bip32RootKey) {\n      return bip32RootKey;\n    }\n    let extendedKey = bip32.fromBase58(\n      bip32RootKey,\n      network.BITCOIN_SV_REGTEST\n    );\n    const pathBits = path.split('/');\n    for (let i = 0; i < pathBits.length; i++) {\n      const bit = pathBits[i];\n      const index = parseInt(bit);\n      if (isNaN(index)) {\n        continue;\n      }\n      const hardened = bit[bit.length - 1] === \"'\";\n      if (hardened) {\n        extendedKey = extendedKey.deriveHardened(index);\n      } else {\n        extendedKey = extendedKey.derive(index);\n      }\n    }\n    return extendedKey.toBase58();\n  }\n\n  getBIP32ExtendedPrivKey = (bip32ExtendedKey: string) => {\n    const bip32Interface = bip32.fromBase58(\n      bip32ExtendedKey,\n      network.BITCOIN_SV_REGTEST\n    );\n    let xprvkeyB58 = 'NA';\n    if (!bip32Interface.isNeutered()) {\n      xprvkeyB58 = bip32Interface.toBase58();\n    }\n    return xprvkeyB58;\n  };\n\n  getBIP32ExtendedPubKey = (bip32ExtendedKey: string) => {\n    const bip32Interface = bip32.fromBase58(\n      bip32ExtendedKey,\n      network.BITCOIN_SV_REGTEST\n    );\n    return bip32Interface.neutered().toBase58();\n  };\n\n  _generateDerivedKeys(\n    bip32ExtendedKey: string,\n    derivationPath: string,\n    index: number,\n    useBip38?: boolean,\n    bip38password: string = '',\n    useHardenedAddresses?: boolean\n  ) {\n    const bip32Interface = bip32.fromBase58(\n      bip32ExtendedKey,\n      network.BITCOIN_SV_REGTEST\n    );\n    let key;\n    if (useHardenedAddresses) {\n      key = bip32Interface.deriveHardened(index);\n    } else {\n      key = bip32Interface.derive(index);\n    }\n    const useUncompressed = useBip38;\n    let keyPair = ECPair.fromPrivateKey(key.privateKey!, {\n      network: network.BITCOIN_SV_REGTEST,\n    });\n    if (useUncompressed) {\n      keyPair = ECPair.fromPrivateKey(key.privateKey!, {\n        compressed: false,\n        network: network.BITCOIN_SV_REGTEST,\n      });\n    }\n    const address = payments.p2pkh({\n      pubkey: keyPair.publicKey,\n      network: network.BITCOIN_SV_REGTEST,\n    }).address!;\n    let indexText = derivationPath + '/' + index;\n    if (useHardenedAddresses) {\n      indexText = indexText + \"'\";\n    }\n    return { indexText, address };\n  }\n\n  _getPrivKey(\n    bip32ExtendedKey: string,\n    index: number,\n    useBip38?: boolean,\n    bip38password: string = '',\n    useHardenedAddresses?: boolean\n  ): { privkey: string } {\n    const bip32Interface = bip32.fromBase58(\n      bip32ExtendedKey,\n      network.BITCOIN_SV_REGTEST\n    );\n    let key;\n    if (useHardenedAddresses) {\n      key = bip32Interface.deriveHardened(index);\n    } else {\n      key = bip32Interface.derive(index);\n    }\n    const useUncompressed = useBip38;\n    let keyPair = ECPair.fromPrivateKey(key.privateKey!, {\n      network: network.BITCOIN_SV_REGTEST,\n    });\n    if (useUncompressed) {\n      keyPair = ECPair.fromPrivateKey(key.privateKey!, {\n        compressed: false,\n        network: network.BITCOIN_SV_REGTEST,\n      });\n    }\n    // const address = payments.p2pkh({\n    //   pubkey: keyPair.publicKey,\n    //   network: network.BITCOIN_SV_REGTEST,\n    // }).address!;\n    const hasPrivkey = !key.isNeutered();\n    let privkey = '';\n    if (hasPrivkey) {\n      privkey = keyPair.toWIF();\n      // if (useBip38) {\n      //   privkey = bip38.encrypt(keyPair.privateKey!, false, bip38password);\n      // }\n    }\n    // const pubkey = keyPair.publicKey.toString('hex');\n    // let indexText =\n    //   derivationPaths.BITCOIN_SV_REGTEST.BIP44.derivationPath + '/' + index;\n    // if (useHardenedAddresses) {\n    //   indexText = indexText + \"'\";\n    // }\n    // if (index === 0) {\n    //   return {\n    //     privkey: 'cQmNC5DxFdWhEqmzeWZ1Gk62hmLTai8vs9fvRVz2KsxKd9fYJTWH',\n    //   };\n    // }\n    return { privkey };\n  }\n\n  async generateDerivedKeys(\n    bip32ExtendedKey: string,\n    derivationPath: string,\n    indexStart: number,\n    count: number,\n    useBip38: boolean,\n    bip38password?: string,\n    useHardenedAddresses?: boolean\n  ) {\n    const derivedKeys = [];\n    for (let i = indexStart; i < indexStart + count; i++) {\n      // if (i === 0) {\n      //   const derivedKey = { address: '', indexText: 'm/44/1/0/0/0' };\n      //   derivedKey.address = 'msWHgqiPB4dDe7MK455MvkNkixhCZsNKdy';\n      //   derivedKeys.push({ ...derivedKey, isUsed: false });\n      // } else {\n      const derivedKey = this._generateDerivedKeys(\n        bip32ExtendedKey,\n        derivationPath,\n        i,\n        useBip38,\n        bip38password,\n        useHardenedAddresses\n      );\n      derivedKeys.push({ ...derivedKey, isUsed: false });\n      // }\n    }\n    return { derivedKeys };\n  }\n\n  _getAddressesFromKeys(derivedKeys: any[]) {\n    return derivedKeys.map((key: { address: any }) => key.address);\n  }\n\n  _countOfUnusedKeys(keys: any[]) {\n    return keys.reduce((acc: number, currKey: { isUsed: boolean }) => {\n      if (!currKey.isUsed) {\n        acc = acc + 1;\n      }\n      return acc;\n    }, 0);\n  }\n\n  _removeDuplicate(outputs: any[]) {\n    const sortedOutputs = outputs.sort(\n      (output1: { blockHeight: number }, output2: { blockHeight: number }) => {\n        const a =\n          output1.blockHeight !== null ? output1.blockHeight : 999999999;\n        const b =\n          output2.blockHeight !== null ? output2.blockHeight : 999999999;\n        return b - a;\n      }\n    );\n    const unconfirmedOutputs = [];\n    for (let index = 0; index < sortedOutputs.length; index++) {\n      const output = sortedOutputs[index];\n      if (output.txIndex === null) {\n        unconfirmedOutputs.push(output);\n      } else {\n        break;\n      }\n    }\n    if (unconfirmedOutputs.length > 0) {\n      const duplicateOutputs = sortedOutputs.splice(\n        0,\n        unconfirmedOutputs.length * 2\n      );\n      const uniqueOutputs = duplicateOutputs.filter((element, index, self) => {\n        return (\n          index ===\n          self.findIndex(\n            (t) =>\n              t.outputTxHash === element.outputTxHash &&\n              t.outputIndex === element.outputIndex\n          )\n        );\n      });\n      return [...uniqueOutputs, ...sortedOutputs];\n    }\n    return sortedOutputs;\n  }\n\n  async processAllegoryTransactions(outputs: any[], transactions: any[]) {\n    const allegoryTransactions = transactions.filter((transaction) => {\n      if (\n        transaction.outputs.length > 0 &&\n        transaction.outputs[0].lockingScript.startsWith(\n          '006a0f416c6c65676f72792f416c6c506179'\n        )\n      ) {\n        return true;\n      }\n      return false;\n    });\n    const confirmedNamePurchaseTxs: any[] = [];\n    allegoryTransactions.forEach((allegoryTransaction) => {\n      const allegoryData = decodeCBORData(\n        allegoryTransaction.outputs[0].lockingScript\n      );\n      const allegory = getAllegoryType(allegoryData);\n      const { name, action } = allegory;\n      let producerExtensions: { codePoint: number; index: any }[] = [];\n      if (action instanceof ProducerAction) {\n        const producerAction = action as ProducerAction;\n        if (producerAction.extensions.length > 0) {\n          producerExtensions = producerAction.extensions.map(\n            (extension: Extension) => {\n              if (extension instanceof ProducerExtension) {\n                return {\n                  codePoint: extension.codePoint,\n                  index: (extension as ProducerExtension).producerOutputEx\n                    .producer.index,\n                };\n              } else {\n                return {\n                  codePoint: extension.codePoint,\n                  index: (extension as OwnerExtension).ownerOutputEx.owner\n                    .index,\n                };\n              }\n            }\n          );\n        }\n      }\n      const producerCodePoints = producerExtensions?.map(\n        ({ codePoint }) => codePoint\n      );\n      confirmedNamePurchaseTxs.push({\n        name: utils.codePointToName([...name, ...producerCodePoints]),\n        index:\n          producerExtensions.length > 0 ? producerExtensions[0].index : null,\n        tx: allegoryTransaction,\n      });\n    });\n    const validConfirmedNamePurchaseTxs: any[] = [];\n    for (let index = 0; index < confirmedNamePurchaseTxs.length; index++) {\n      const confirmedNamePurchaseTx = confirmedNamePurchaseTxs[index];\n      const {\n        name,\n        tx: { txId },\n      } = confirmedNamePurchaseTx;\n      if (name) {\n        try {\n          const { data } = await post('allegory/name-outpoint', {\n            name: utils.getCodePoint(name),\n            isProducer: false,\n          });\n          const {\n            forName,\n            isProducer,\n            outPoint: { opIndex, opTxHash },\n            script,\n          } = data;\n          if (utils.codePointToName(forName) === name && txId === opTxHash) {\n            validConfirmedNamePurchaseTxs.push(confirmedNamePurchaseTx);\n          }\n        } catch (error) {}\n      }\n    }\n    const updatedOutputs = outputs.map(\n      (output: { outputTxHash: any; outputIndex: any }) => {\n        const nameOutput = validConfirmedNamePurchaseTxs.find(\n          (validConfirmedNamePurchaseTx: { tx: any; index: any }) => {\n            return (\n              output.outputTxHash === validConfirmedNamePurchaseTx.tx.txId &&\n              output.outputIndex === validConfirmedNamePurchaseTx.index\n            );\n          }\n        );\n\n        if (nameOutput) {\n          return {\n            ...output,\n            name: nameOutput.name,\n            isNameOutpoint: true,\n          };\n        } else {\n          return output;\n        }\n      }\n    );\n    return { outputs: updatedOutputs };\n  }\n\n  async getTransactions(options?: {\n    startkey?: string;\n    limit?: number;\n    pageNo?: number;\n    diff?: boolean;\n  }) {\n    const { existingDerivedKeys } = await Persist.getDerivedKeys();\n    const { existingNUTXODerivedKeys } = await Persist.getNUTXODerivedKeys();\n    const keys = [...existingDerivedKeys, ...existingNUTXODerivedKeys];\n    if (keys.length > 0) {\n      const {\n        derivedKeys: newDerivedKeys,\n        nUTXODerivedKeys: newNUTXODerivedKeys,\n        diffOutputs: diffOutputsWithDuplicate,\n      } = await this._getOutputs(keys);\n      if (diffOutputsWithDuplicate.length > 0) {\n        const diffOutputs = this._removeDuplicate(diffOutputsWithDuplicate);\n        const newKeys = [...newDerivedKeys, ...newNUTXODerivedKeys];\n        /* FIX: A Tx can be in spendInfo, and it may not appear in getOutputs API */\n        const spentOutputs = diffOutputs.filter(\n          (output: { spendInfo: any }) => {\n            if (output.spendInfo) return true;\n            return false;\n          }\n        );\n        const outgoingTxIds: string[] = Array.from(\n          new Set(\n            spentOutputs.map(\n              (output: { spendInfo: { spendingTxId: any } }) =>\n                output.spendInfo.spendingTxId\n            )\n          )\n        );\n        const incomingTxIds: string[] = Array.from(\n          new Set(\n            diffOutputs.map(\n              (output: { outputTxHash: any }) => output.outputTxHash\n            )\n          )\n        );\n        const txIds: string[] = Array.from(\n          new Set([...incomingTxIds, ...outgoingTxIds])\n        );\n        const { txs } = await this._getTransactions(txIds);\n        const { chainInfo } = await chainAPI.getChainInfo();\n        if (chainInfo) {\n          const { chainTip } = chainInfo;\n          if (txs.length > 0) {\n            const sortedTx = txs.sort(\n              (tx1: { blockHeight: number }, tx2: { blockHeight: number }) => {\n                return tx2.blockHeight - tx1.blockHeight;\n              }\n            );\n            const transactions: {\n              txId: any;\n              inputs: any;\n              outputs: any;\n              confirmation?: number | null;\n            }[] = sortedTx.map(\n              (transaction: { txId?: any; tx?: any; blockHeight?: any }) => {\n                const {\n                  tx: { txInps, txOuts },\n                  blockHeight,\n                } = transaction;\n                const newTxInps = txInps.map(\n                  (input: {\n                    address: string;\n                    txInputIndex: number;\n                    value: number;\n                  }) => {\n                    const isMineAddress = newKeys.find(\n                      (derivedKey: { address: any }) =>\n                        derivedKey.address === input.address\n                    );\n                    const isNUTXOAddress = newNUTXODerivedKeys.find(\n                      (derivedKey: { address: any }) =>\n                        derivedKey.address === input.address\n                    );\n                    return {\n                      address: input.address,\n                      txInputIndex: input.txInputIndex,\n                      value: input.value,\n                      isMine: isMineAddress ? true : false,\n                      isNUTXO: isNUTXOAddress ? true : false,\n                    };\n                  }\n                );\n                const newTxOuts = txOuts.map(\n                  (output: {\n                    address: string;\n                    lockingScript: string;\n                    outputIndex: number;\n                    value: number;\n                  }) => {\n                    const isMineAddress = newKeys.find(\n                      (derivedKey: { address: any }) =>\n                        derivedKey.address === output.address\n                    );\n                    const isNUTXOAddress = newNUTXODerivedKeys.find(\n                      (derivedKey: { address: any }) =>\n                        derivedKey.address === output.address\n                    );\n                    return {\n                      address: output.address,\n                      lockingScript: output.lockingScript,\n                      outputIndex: output.outputIndex,\n                      value: output.value,\n                      isMine: isMineAddress ? true : false,\n                      isNUTXO: isNUTXOAddress ? true : false,\n                    };\n                  }\n                );\n                const newTransaction = {\n                  txId: transaction.txId,\n                  inputs: newTxInps,\n                  outputs: newTxOuts,\n                };\n                return {\n                  ...newTransaction,\n                  confirmation: blockHeight ? chainTip - blockHeight : null,\n                };\n              }\n            );\n            const {\n              outputs: newDiffOutputs,\n            } = await this.processAllegoryTransactions(\n              diffOutputs,\n              transactions\n            );\n            await Persist.upsertOutputs(newDiffOutputs);\n            await Persist.upsertTransactions(transactions);\n            await Persist.upsertDerivedKeys(newDerivedKeys);\n            await Persist.upsertNUTXODerivedKeys(newNUTXODerivedKeys);\n            if (options?.diff) {\n              return { transactions };\n            } else {\n              return await Persist.getTransactions(options);\n            }\n          } else {\n            throw new Error('Error in fetching transactions');\n          }\n        } else {\n          throw new Error('Error in fetching transactions');\n        }\n      } else {\n        if (options?.diff) {\n          return { transactions: [] };\n        } else {\n          return await Persist.getTransactions(options);\n        }\n      }\n    }\n    return { transactions: [] };\n  }\n\n  async _getTransactions(txIds: string[]) {\n    const chunkedTxIds = _.chunk(txIds, 20);\n    const data = await Promise.all(\n      chunkedTxIds.map(async (chunkedTxId) => {\n        return await transactionAPI.getTransactionsByTxIDs(chunkedTxId);\n      })\n    );\n    const transactions = data.map((element) => element.txs).flat();\n    return { txs: transactions };\n  }\n\n  async _getOutputs(\n    derivedKeys: any[],\n    prevDiffOutputs: any[] = [],\n    prevKeys: any[] = []\n  ): Promise<any> {\n    const chunkedUsedDerivedKeys = _.chunk(derivedKeys, 20);\n    const outputsByAddresses = await Promise.all(\n      chunkedUsedDerivedKeys.map(async (chunkedUsedDerivedKey) => {\n        return await this._getOutputsByAddresses(chunkedUsedDerivedKey);\n      })\n    );\n    const diffOutputs = outputsByAddresses.flat();\n    const updatedKeys = derivedKeys.map(\n      (key: { address: string; indexText: string; isUsed: boolean }) => {\n        if (!key.isUsed) {\n          const found = diffOutputs.some(\n            (output: { address: any }) => output.address === key.address\n          );\n          return { ...key, isUsed: found };\n        }\n        return key;\n      }\n    );\n    const newDiffOutputs = [...prevDiffOutputs, ...diffOutputs];\n    const newKeys = [...prevKeys, ...updatedKeys];\n    const walletKeys = newKeys.filter((key: { indexText: string }) => {\n      return key.indexText.startsWith(\n        derivationPaths.BITCOIN_SV_REGTEST.BIP44.derivationPath\n      );\n    });\n    const nUTXOKeys = newKeys.filter((key: { indexText: string }) => {\n      return key.indexText.startsWith(\n        derivationPaths.BITCOIN_SV_REGTEST.BIP44.nUTXODerivationPath\n      );\n    });\n    const countOfUnusedKeys = this._countOfUnusedKeys(walletKeys);\n    const countOfUnusedNUTXOKeys = this._countOfUnusedKeys(nUTXOKeys);\n    if (countOfUnusedKeys < 20 || countOfUnusedNUTXOKeys < 20) {\n      const bip32ExtendedKey = await Persist.getBip32ExtendedKey();\n      const lastKeyIndex = walletKeys[walletKeys.length - 1].indexText\n        .split('/')\n        .pop();\n\n      const { derivedKeys: nextDerivedKeys } = await this.generateDerivedKeys(\n        bip32ExtendedKey,\n        derivationPaths.BITCOIN_SV_REGTEST.BIP44.derivationPath,\n        Number(lastKeyIndex) + 1,\n        20 - countOfUnusedKeys,\n        false\n      );\n\n      const nUTXOExtendedKey = await Persist.getNUTXOExtendedKey();\n      const lastNUTXOKeyIndex = nUTXOKeys[nUTXOKeys.length - 1].indexText\n        .split('/')\n        .pop();\n      const {\n        derivedKeys: nextNUTXODerivedKeys,\n      } = await this.generateDerivedKeys(\n        nUTXOExtendedKey,\n        derivationPaths.BITCOIN_SV_REGTEST.BIP44.nUTXODerivationPath,\n        Number(lastNUTXOKeyIndex) + 1,\n        20 - countOfUnusedNUTXOKeys,\n        false\n      );\n\n      const nextKeys = [...nextDerivedKeys, ...nextNUTXODerivedKeys];\n\n      return await this._getOutputs(nextKeys, newDiffOutputs, newKeys);\n    } else {\n      return {\n        diffOutputs: newDiffOutputs,\n        derivedKeys: walletKeys,\n        nUTXODerivedKeys: nUTXOKeys,\n      };\n    }\n  }\n\n  async _getOutputsByAddresses(\n    keys: any[],\n    prevOutputs: any[] = [],\n    nextCursor?: number\n  ): Promise<any> {\n    const addresses = this._getAddressesFromKeys(keys);\n    const data: {\n      outputs: any[];\n      nextCursor: number;\n    } = await addressAPI.getOutputsByAddresses(addresses, 100, nextCursor);\n    const { outputs } = await Persist.getOutputs();\n    if (outputs.length > 0) {\n      const diffOutputs = await this._getDiffOutputs(data.outputs);\n      if (diffOutputs.length === data.outputs.length) {\n        const outputs = [...prevOutputs, ...diffOutputs];\n        if (data.nextCursor) {\n          return await this._getOutputsByAddresses(\n            keys,\n            outputs,\n            data.nextCursor\n          );\n        } else {\n          return outputs;\n        }\n      } else {\n        return [...prevOutputs, ...diffOutputs];\n      }\n    } else {\n      const outputs = [...prevOutputs, ...data.outputs];\n      if (data.nextCursor) {\n        return await this._getOutputsByAddresses(\n          keys,\n          outputs,\n          data.nextCursor\n        );\n      } else {\n        return outputs;\n      }\n    }\n  }\n\n  async _getDiffOutputs(outputs: any) {\n    const newOutputs: any[] = [];\n    for (let index = 0; index < outputs.length; index++) {\n      if (!(await Persist.isInOutputs(outputs[index]))) {\n        newOutputs.push(outputs[index]);\n      } else {\n        return newOutputs;\n      }\n    }\n    return newOutputs;\n  }\n\n  async getUnusedNUTXOAddress() {\n    const { existingNUTXODerivedKeys } = await Persist.getNUTXODerivedKeys();\n    const unusedNUTXODerivedKeys = existingNUTXODerivedKeys\n      .filter(\n        (existingDerivedKey: { isUsed: any }) =>\n          existingDerivedKey.isUsed === false\n      )\n      .map(\n        ({ indexText, address }: { indexText: string; address: string }) =>\n          address\n      );\n    return unusedNUTXODerivedKeys.find(Boolean);\n  }\n\n  async _getKeys(addresses: string[]): Promise<object[]> {\n    const { existingDerivedKeys } = await Persist.getDerivedKeys();\n    const { existingNUTXODerivedKeys } = await Persist.getNUTXODerivedKeys();\n    const keys = [...existingDerivedKeys, ...existingNUTXODerivedKeys];\n    const bip32ExtendedKey = await Persist.getBip32ExtendedKey();\n    const nUTXOExtendedKey = await Persist.getNUTXOExtendedKey();\n\n    return addresses.map((address) => {\n      const derivedKey = keys.find(\n        (derivedKey: { address: string }) => derivedKey.address === address\n      );\n      let extendedKey;\n      if (\n        derivedKey.indexText.startsWith(\n          derivationPaths.BITCOIN_SV_REGTEST.BIP44.derivationPath\n        )\n      ) {\n        extendedKey = bip32ExtendedKey;\n      } else {\n        extendedKey = nUTXOExtendedKey;\n      }\n      const KeyIndex = derivedKey.indexText.split('/').pop();\n      const { privkey } = this._getPrivKey(\n        extendedKey,\n        Number(KeyIndex),\n        false\n      );\n      return ECPair.fromWIF(privkey, networks.regtest);\n    });\n  }\n\n  async updateTransactionsConfirmations() {\n    const { transactions } = await Persist.getTransactionsByConfirmations();\n    const txIds = transactions.map((tx: { txId: any }) => tx.txId);\n    if (txIds.length > 0) {\n      const { txs } = await this._getTransactions(txIds);\n      if (txs.length > 0) {\n        const { chainInfo } = await chainAPI.getChainInfo();\n        if (chainInfo) {\n          const { chainTip } = chainInfo;\n          const txsWithConfirmation = txs.map(\n            (transaction: { blockHeight?: any; txId: string }) => {\n              const { blockHeight } = transaction;\n              return {\n                ...transaction,\n                confirmation: blockHeight ? chainTip - blockHeight : null,\n              };\n            }\n          );\n\n          const updatedTransactions: any[] = [];\n          const deletedTransactions: any[] = [];\n          const unconfirmedTransactions: any[] = [];\n          transactions.forEach(\n            (transaction: { txId: string; confirmation: number | null }) => {\n              const matchedTxWithConfirmation = txsWithConfirmation.find(\n                (tx: { txId: string; confirmation: number | null }) =>\n                  tx.txId === transaction.txId\n              );\n              if (\n                matchedTxWithConfirmation &&\n                matchedTxWithConfirmation.confirmation !==\n                  transaction.confirmation\n              ) {\n                updatedTransactions.push({\n                  ...transaction,\n                  confirmation: matchedTxWithConfirmation.confirmation,\n                });\n              } else if (transaction.confirmation === null) {\n                unconfirmedTransactions.push({\n                  ...transaction,\n                });\n              }\n            }\n          );\n          await Persist.upsertTransactions(updatedTransactions);\n\n          if (unconfirmedTransactions.length > 0) {\n            for (\n              let index = 0;\n              index < unconfirmedTransactions.length;\n              index++\n            ) {\n              const unconfirmedTransaction = unconfirmedTransactions[index];\n              const diffInMinutes = differenceInMinutes(\n                new Date(),\n                Date.parse(unconfirmedTransaction.createdAt)\n              );\n              if (diffInMinutes > 30) {\n                // make inputs of the tx as unspent\n                const unspentOutputs = unconfirmedTransaction.inputs.map(\n                  (input: { outputTxHash: string; txInputIndex: number }) => {\n                    return {\n                      outputTxHash: input.outputTxHash,\n                      outputIndex: input.txInputIndex,\n                    };\n                  }\n                );\n                await Persist.markOutputAsUnspent(unspentOutputs);\n\n                // delete own outputs of this tx\n                const ownOutputs = unconfirmedTransaction.outputs.filter(\n                  (output: { isMine: boolean }) => output.isMine === true\n                );\n                const deletedOutputs = ownOutputs.map(\n                  (output: { outputIndex: number }) => {\n                    return {\n                      outputTxHash: unconfirmedTransaction.txId,\n                      outputIndex: output.outputIndex,\n                    };\n                  }\n                );\n                await Persist.deleteOutputs(deletedOutputs);\n\n                // delete transaction\n                deletedTransactions.push(unconfirmedTransaction);\n                await Persist.deleteTransactions([unconfirmedTransaction]);\n              }\n            }\n            return {\n              updatedTransactions,\n              deletedTransactions,\n            };\n          }\n          return { updatedTransactions, deletedTransactions };\n        }\n      }\n    }\n    return { updatedTransactions: [], deletedTransactions: [] };\n  }\n\n  async relayTx(\n    psbt: Psbt,\n    transaction: Transaction,\n    inputs: any[],\n    ownOutputs: any[]\n  ) {\n    const transactionHex = transaction.toHex();\n    const base64 = Buffer.from(transactionHex, 'hex').toString('base64');\n    const { txBroadcast } = await transactionAPI.broadcastRawTransaction(\n      base64\n    );\n    if (txBroadcast) {\n      const spentUtxos = inputs.map((input: any) => ({\n        ...input,\n        isSpent: true,\n      }));\n      const changeOutputs = ownOutputs.map(\n        (ownOutput: { address: string }, index) => {\n          const transactionOutput = transaction.outs.find((output, index) => {\n            if (\n              !Buffer.from(output.script)\n                .toString('hex')\n                .startsWith('006a0f416c6c65676f72792f416c6c506179')\n            ) {\n              const p2pkh = payments.p2pkh({\n                output: output.script,\n                network: network.BITCOIN_SV_REGTEST,\n              });\n\n              return ownOutput.address === p2pkh.address!;\n            }\n            return false;\n          });\n          const transactionIndex = transaction.outs.findIndex(\n            (output, index) => {\n              if (\n                !Buffer.from(output.script)\n                  .toString('hex')\n                  .startsWith('006a0f416c6c65676f72792f416c6c506179')\n              ) {\n                const p2pkh = payments.p2pkh({\n                  output: output.script,\n                  network: network.BITCOIN_SV_REGTEST,\n                });\n\n                return ownOutput.address === p2pkh.address!;\n              }\n              return false;\n            }\n          );\n\n          return {\n            address: ownOutput.address,\n            isSpent: false,\n            outputIndex: transactionIndex,\n            outputTxHash: transaction.getId(),\n            value: transactionOutput?.value,\n          };\n        }\n      );\n      const unconfirmedTransaction = {\n        txId: transaction.getId(),\n        inputs: transaction.ins.map((input, index) => {\n          const p2pkh = payments.p2pkh({\n            input: input.script,\n            network: network.BITCOIN_SV_REGTEST,\n          });\n          const isMineInput = inputs.find(\n            (inp: { outputTxHash: string; outputIndex: number }) => {\n              return (\n                inp.outputTxHash ===\n                  Buffer.from(input.hash).reverse().toString('hex') &&\n                inp.outputIndex === input.index\n              );\n            }\n          );\n          return {\n            address: p2pkh.address!,\n            isMine: isMineInput ? true : false,\n            isNUTXO: isMineInput && isMineInput.isNameOutpoint ? true : false,\n            txInputIndex: input.index,\n            outputTxHash: Buffer.from(input.hash).reverse().toString('hex'),\n            value: psbt.data.inputs[index].witnessUtxo?.value,\n          };\n        }),\n        outputs: transaction.outs.map((output, index) => {\n          if (\n            !Buffer.from(output.script)\n              .toString('hex')\n              .startsWith('006a0f416c6c65676f72792f416c6c506179')\n          ) {\n            const p2pkh = payments.p2pkh({\n              output: output.script,\n              network: network.BITCOIN_SV_REGTEST,\n            });\n            const isMineOutput = ownOutputs.find(\n              (ownOutput: { address: string }) => {\n                return ownOutput.address === p2pkh.address!;\n              }\n            );\n            return {\n              address: p2pkh.address!,\n              isMine: isMineOutput ? true : false,\n              isNUTXO:\n                isMineOutput && isMineOutput.type === 'nUTXO' ? true : false,\n              lockingScript: Buffer.from(output.script).toString('hex'),\n              outputIndex: index,\n              value: output.value,\n            };\n          } else {\n            return {\n              address: null,\n              isMine: false,\n              isNUTXO: false,\n              lockingScript: Buffer.from(output.script).toString('hex'),\n              outputIndex: index,\n              value: output.value,\n            };\n          }\n        }),\n        confirmation: null,\n        createdAt: new Date(),\n      };\n      const { outputs } = await this.processAllegoryTransactions(\n        changeOutputs,\n        [unconfirmedTransaction]\n      );\n      await this.markAddressesUsed(ownOutputs.map(({ address }) => address));\n      await Persist.upsertOutputs(spentUtxos);\n      await Persist.upsertOutputs(outputs);\n      await Persist.upsertTransactions([unconfirmedTransaction]);\n      return { transaction: unconfirmedTransaction, txBroadcast };\n    }\n    throw new Error('Broadcast failed');\n  }\n\n  async _createSendTransaction(utxos: any[], targets: any[], feeRate: number) {\n    try {\n      // let feeRate = 5; // satoshis per byte\n      // if (transactionFee === 0) {\n      //   feeRate = 0;\n      // }\n      let { inputs, outputs } = coinSelect(utxos, targets, feeRate);\n      if (!inputs || !outputs) throw new Error('Empty inputs or outputs');\n      // if (transactionFee !== fee) {\n      //   const changeOutputs = outputs.filter((output: { address: any }) => {\n      //     if (!output.address) return true;\n      //     return false;\n      //   });\n      //   const diffFee = fee - transactionFee;\n      //   if (changeOutputs.length > 0) {\n      //     changeOutputs[0].value = Number(changeOutputs[0].value) + diffFee;\n      //   }\n      // }\n\n      const psbt = new Psbt({\n        network: network.BITCOIN_SV_REGTEST,\n        forkCoin: 'bch',\n      });\n      psbt.setVersion(1);\n      inputs.forEach(\n        (input: {\n          outputTxHash: any;\n          outputIndex: any;\n          address: string;\n          value: number;\n        }) => {\n          const p2pkh = payments.p2pkh({\n            address: input.address,\n            network: network.BITCOIN_SV_REGTEST,\n          });\n          psbt.addInput({\n            hash: input.outputTxHash,\n            index: input.outputIndex,\n            witnessUtxo: {\n              script: p2pkh.output!,\n              value: input.value,\n            },\n          });\n        }\n      );\n      const usedAddresses: any[] = [];\n      for (let index = 0; index < outputs.length; index++) {\n        const output = outputs[index];\n        if (!output.address) {\n          const { unusedAddresses } = await this.getUnusedAddresses({\n            excludeAddresses: usedAddresses,\n          });\n          const address = unusedAddresses[0];\n          usedAddresses.push({ type: '', title: '', address });\n          output.address = address;\n        }\n        psbt.addOutput({\n          address: output.address,\n          value: output.value,\n        });\n      }\n      const addresses = inputs.map(\n        (input: { address: string }) => input.address\n      );\n      const keys: object[] = await this._getKeys(addresses);\n      keys.forEach((key: any, i) => {\n        psbt.signInput(i, key);\n      });\n      psbt.validateSignaturesOfAllInputs();\n      psbt.finalizeAllInputs();\n      const transaction = psbt.extractTransaction(true);\n      return await this.relayTx(psbt, transaction, inputs, usedAddresses);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async createSendTransaction(\n    receiverAddress: string,\n    amountInSatoshi: number,\n    feeRate: number\n  ) {\n    const { utxos } = await Persist.getUTXOs();\n    const targets = [\n      { address: receiverAddress, value: Number(amountInSatoshi) },\n    ];\n    return await this._createSendTransaction(utxos, targets, feeRate);\n  }\n\n  async getTransactionFee(\n    receiverAddress: string,\n    amountInSatoshi: number,\n    feeRate: number\n  ) {\n    try {\n      const { utxos } = await Persist.getUTXOs();\n      const targets = [\n        { address: receiverAddress, value: Number(amountInSatoshi) },\n      ];\n      let { fee } = coinSelect(utxos, targets, feeRate);\n      // if (!inputs) throw new Error('Not sufficient funds');\n      // if (!outputs) throw new Error('No Receiver specified');\n      return fee;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async getBalance() {\n    const { outputs } = await Persist.getOutputs();\n    const balance = outputs.reduce((acc: number, currOutput: any) => {\n      if (!currOutput.isSpent) {\n        acc = acc + currOutput.value;\n      }\n      return acc;\n    }, 0);\n    return { balance };\n  }\n\n  generateMnemonic(\n    strength?: number,\n    rng?: (size: number) => Buffer,\n    wordlist?: string[]\n  ): string {\n    return bip39.generateMnemonic(strength, rng, wordlist);\n  }\n\n  async getUsedAddresses() {\n    const { outputs } = await Persist.getOutputs();\n    const outputsGroupedByAddress = _.groupBy(outputs, (output) => {\n      return output.address;\n    });\n    const usedAddresses: {\n      address: string;\n      incomingBalance: number;\n      outgoingBalance: number;\n      currentBalance: number;\n      lastTransaction: any;\n    }[] = [];\n    for (const [address, outputs] of Object.entries(outputsGroupedByAddress)) {\n      const currentBalance = outputs.reduce((acc: number, currOutput: any) => {\n        if (!currOutput.spendInfo) {\n          acc = acc + currOutput.value;\n        }\n        return acc;\n      }, 0);\n      let incomingBalance = 0;\n      let outgoingBalance = 0;\n      outputs.forEach((output) => {\n        if (output.spendInfo) {\n          outgoingBalance = outgoingBalance + output.value;\n        }\n        incomingBalance = incomingBalance + output.value;\n      });\n      usedAddresses.push({\n        address,\n        incomingBalance,\n        outgoingBalance,\n        currentBalance,\n        lastTransaction: outputs[0].address,\n      });\n    }\n    return {\n      usedAddresses,\n    };\n  }\n\n  async getUnusedAddresses(options?: {\n    excludeAddresses?: string[];\n    count?: number;\n  }): Promise<{ unusedAddresses: any[] }> {\n    const { existingDerivedKeys } = await Persist.getDerivedKeys();\n    const unusedAddresses = existingDerivedKeys\n      .filter(\n        (existingDerivedKey: { isUsed: any }) =>\n          existingDerivedKey.isUsed === false\n      )\n      .map(({ address }: { address: string }) => address);\n    if (options?.excludeAddresses) {\n      const filteredUnusedAddresses = unusedAddresses.filter(\n        (unusedAddress: string) => {\n          return !options.excludeAddresses?.includes(unusedAddress);\n        }\n      );\n      if (options?.count) {\n        return {\n          unusedAddresses: filteredUnusedAddresses.slice(0, options.count),\n        };\n      } else {\n        return {\n          unusedAddresses: filteredUnusedAddresses.slice(0, 1),\n        };\n      }\n    }\n    if (options?.count) {\n      return {\n        unusedAddresses: unusedAddresses.slice(0, options.count),\n      };\n    }\n    return {\n      unusedAddresses: unusedAddresses.slice(0, 1),\n    };\n  }\n\n  async markAddressesUsed(addresses: string[]) {\n    await Persist.markAddressesUsed(addresses);\n  }\n\n  async login(profileId: string, password: string) {\n    try {\n      const bip39Mnemonic = await Persist.login(profileId, password);\n      await Persist.init(profileId);\n      await this._initWallet(bip39Mnemonic);\n      return { profile: profileId };\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async createProfile(bip39Mnemonic: string, password: string) {\n    const cryptedText = AES.encrypt(bip39Mnemonic, password).toString();\n    const profileName = faker.name.firstName();\n    localStorage.setItem('currentprofile', profileName);\n    try {\n      await Persist.createProfile(cryptedText, profileName);\n      return { profile: profileName };\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async updateProfileName(currentProfileName: string, newProfileName: string) {\n    try {\n      await Persist.updateProfile(currentProfileName, newProfileName);\n      return { profile: newProfileName };\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async getProfiles() {\n    return { profiles: await Persist.getProfiles() };\n  }\n\n  async getUnregisteredName() {\n    return await Persist.getUnregisteredName();\n  }\n\n  async logout() {\n    return await Persist.destroy();\n  }\n\n  async runScript() {\n    const targets = [\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n      { address: 'mruMP6ZsrgnqMs1S39nAJNDrwJd2i12eNx', value: 500 },\n    ];\n    // const { utxos } = await Persist.getUTXOs();\n    // const feeRate = 5;\n    // await this._createSendTransaction(utxos, targets, feeRate);\n    const keys: any[] = await this._getKeys([\n      'mmFXRtUtKN9znnF9DFgQqvKP5TBHZmgmym',\n    ]);\n    console.log(keys[0].privateKey.toString('hex'));\n    // const { utxos } = await Persist.getUTXOs();\n    // const balance = utxos.reduce((acc: number, currOutput: any) => {\n    //   if (!currOutput.isSpent) {\n    //     acc = acc + currOutput.value;\n    //   }\n    //   return acc;\n    // }, 0);\n  }\n}\n\nexport default new Wallet();\n","import sha256 from 'crypto-js/sha256';\nimport coinSelect from 'coinselect';\nimport { Psbt, payments } from 'bitcoinjs-lib';\nimport { decodeCBORData, getAllegoryType, OwnerAction } from './Allegory';\nimport wallet from './Wallet';\nimport utils from './Utils';\nimport { post } from './httpClient';\nimport * as Persist from './Persist';\nimport { transactionAPI } from './TransactionAPI';\nimport Config from './Config.json';\nimport network from './constants/network';\n\nclass Allpay {\n  async buyName(data: {\n    host: string;\n    port: number;\n    name: number[];\n    priceInSatoshi: number;\n    isProducer: boolean;\n  }) {\n    try {\n      const { host, port, name, isProducer } = data;\n      const priceInSatoshi = 1000000;\n      const feeRate = 0;\n      const { utxos } = await Persist.getUTXOs();\n      const targets = [{ value: Number(priceInSatoshi) }];\n      let { inputs, outputs } = coinSelect(utxos, targets, feeRate);\n      if (!inputs || !outputs) throw new Error('Empty inputs or outputs');\n      const paymentInputs = inputs.map((input: any) => {\n        return [\n          {\n            opTxHash: input.outputTxHash,\n            opIndex: input.outputIndex,\n          },\n          input.value,\n        ];\n      });\n      const outputOwner = await wallet.getUnusedNUTXOAddress();\n      const { unusedAddresses } = await wallet.getUnusedAddresses();\n      const outputChange = unusedAddresses[0];\n      if (outputOwner && outputChange) {\n        const {\n          data: { psaTx: psaBase64 },\n        } = await post(\n          'partialsign',\n          {\n            paymentInputs,\n            name: [name, isProducer],\n            outputOwner,\n            outputChange,\n          },\n          {\n            baseURL: `https://${host}:${port}/v1`,\n          }\n        );\n        const { psbt } = await this.decodeTransaction(psaBase64, inputs);\n        // const snv = await this.verifyRootTx({ psbt });\n        const ownOutputs = [\n          { type: 'nUTXO', title: 'Name UTXO', address: outputOwner },\n          { type: '', title: '', address: outputChange },\n        ];\n        return {\n          psbt,\n          outpoint: { name, isProducer },\n          inputs,\n          ownOutputs,\n          snv: true,\n        };\n      } else {\n        throw new Error('Error configuring input params');\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async decodeTransaction(\n    psaBase64: string,\n    inputs: any[],\n    addFunding?: boolean\n  ) {\n    const partiallySignTransaction = JSON.parse(\n      Buffer.from(psaBase64, 'base64').toString()\n    );\n    try {\n      const psbt = new Psbt({\n        network: network.BITCOIN_SV_REGTEST,\n        forkCoin: 'bch',\n      });\n      psbt.setVersion(1);\n      partiallySignTransaction.ins.forEach(\n        (input: {\n          outpoint: { hash: string; index: number };\n          sequence: number;\n          script: string;\n          value: number;\n        }) => {\n          if (input.script) {\n            const p2pkh = payments.p2pkh({\n              input: Buffer.from(input.script, 'hex'),\n              network: network.BITCOIN_SV_REGTEST,\n            });\n            psbt.addInput({\n              hash: input.outpoint.hash,\n              index: input.outpoint.index,\n              sequence: input.sequence,\n              witnessUtxo: {\n                script: p2pkh.output!,\n                value: input.value,\n              },\n            });\n          } else {\n            const utxoInput = inputs.find((inp) => {\n              return (\n                inp.outputTxHash === input.outpoint.hash &&\n                inp.outputIndex === input.outpoint.index\n              );\n            });\n            if (utxoInput) {\n              const p2pkh = payments.p2pkh({\n                address: utxoInput.address,\n                network: network.BITCOIN_SV_REGTEST,\n              });\n              psbt.addInput({\n                hash: input.outpoint.hash,\n                index: input.outpoint.index,\n                sequence: input.sequence,\n                witnessUtxo: {\n                  script: p2pkh.output!,\n                  value: utxoInput.value,\n                },\n              });\n            } else {\n              throw new Error('Error in setting psbt inputs');\n            }\n          }\n        }\n      );\n      let fundingInputs: any[] = [];\n      const ownOutputs: { type: string; title: ''; address: string }[] = [];\n      if (addFunding) {\n        const { utxos } = await Persist.getUTXOs();\n        const feeRate = 5000;\n        const amountInSatoshi = 10000;\n        const targets = [{ value: Number(amountInSatoshi) }];\n        const { inputs, outputs } = coinSelect(utxos, targets, feeRate);\n        fundingInputs = inputs;\n        inputs.forEach(\n          (input: {\n            outputTxHash: any;\n            outputIndex: any;\n            address: string;\n            value: number;\n          }) => {\n            const p2pkh = payments.p2pkh({\n              address: input.address,\n              network: network.BITCOIN_SV_REGTEST,\n            });\n            psbt.addInput({\n              hash: input.outputTxHash,\n              index: input.outputIndex,\n              witnessUtxo: {\n                script: p2pkh.output!,\n                value: input.value,\n              },\n            });\n          }\n        );\n\n        partiallySignTransaction.outs.forEach(\n          (output: { script: any; value: any }, index: number) => {\n            psbt.addOutput({\n              script: Buffer.from(output.script, 'hex'),\n              value: output.value,\n            });\n          }\n        );\n\n        const usedAddresses: string[] = [];\n        for (let index = 0; index < outputs.length; index++) {\n          const output = outputs[index];\n          if (!output.address) {\n            const { unusedAddresses } = await wallet.getUnusedAddresses({\n              excludeAddresses: usedAddresses,\n            });\n            const address = unusedAddresses[0];\n            usedAddresses.push(address);\n            output.address = address;\n            ownOutputs.push({ type: '', title: '', address });\n          }\n          psbt.addOutput({\n            address: output.address,\n            value: output.value,\n          });\n        }\n      } else {\n        partiallySignTransaction.outs.forEach(\n          (output: { script: any; value: any }, index: number) => {\n            psbt.addOutput({\n              script: Buffer.from(output.script, 'hex'),\n              value: output.value,\n            });\n          }\n        );\n      }\n      partiallySignTransaction.ins.forEach(\n        (input: { script: string }, index: number) => {\n          if (input.script) {\n            const p2pkh = payments.p2pkh({\n              input: Buffer.from(input.script, 'hex'),\n              network: network.BITCOIN_SV_REGTEST,\n            });\n            psbt.updateInput(index, {\n              partialSig: [\n                {\n                  pubkey: p2pkh.pubkey!,\n                  signature: p2pkh.signature!,\n                },\n              ],\n            });\n          }\n        }\n      );\n      return { psbt, fundingInputs, ownOutputs };\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async signRelayTransaction({\n    psbtHex,\n    inputs,\n    ownOutputs,\n  }: {\n    psbtHex: string;\n    inputs: any[];\n    ownOutputs: any[];\n  }) {\n    const psbt: Psbt = Psbt.fromHex(psbtHex, {\n      network: network.BITCOIN_SV_REGTEST,\n      forkCoin: 'bch',\n    });\n    for (let index = 0; index < psbt.data.inputs.length; index++) {\n      const input = psbt.data.inputs[index];\n      if (!input.partialSig) {\n        const txInput = psbt.txInputs[index];\n        const utxo = inputs.find((input) => {\n          return (\n            input.outputTxHash ===\n              Buffer.from(txInput.hash).reverse().toString('hex') &&\n            input.outputIndex === txInput.index\n          );\n        });\n        if (utxo) {\n          const keys: any[] = await wallet._getKeys([utxo.address]);\n          if (keys.length > 0) {\n            const key: any = keys[0];\n            psbt.signInput(index, key);\n          }\n        } else {\n          throw new Error('Error in signing transaction');\n        }\n      }\n    }\n    psbt.validateSignaturesOfAllInputs();\n    psbt.finalizeAllInputs();\n    const transaction = psbt.extractTransaction(true);\n    return await wallet.relayTx(psbt, transaction, inputs, ownOutputs);\n  }\n\n  async verifyRootTx(args: {\n    psbt?: Psbt;\n    transaction?: any;\n  }): Promise<boolean> {\n    const { psbt, transaction } = args;\n    let inputHash;\n    if (psbt || transaction) {\n      if (psbt) {\n        inputHash = Buffer.from(psbt.txInputs[0].hash)\n          .reverse()\n          .toString('hex');\n      }\n      if (transaction) {\n        const { txInps } = transaction;\n        inputHash = txInps[0].outpointTxID;\n      }\n      if (\n        inputHash ===\n        '0000000000000000000000000000000000000000000000000000000000000000'\n      ) {\n        return false;\n      } else if (inputHash === Config.allegoryRootNode) {\n        return true;\n      } else {\n        const {\n          tx: { tx },\n        } = await transactionAPI.getTransactionByTxID(inputHash);\n        return await this.verifyRootTx({ transaction: tx });\n      }\n    }\n    return false;\n  }\n\n  verifyMerkelRoot(args: {\n    leafNode: string;\n    merkelRoot: string;\n    proof: any[];\n  }) {\n    const { leafNode, merkelRoot, proof } = args;\n    let merkelProof = proof;\n    let finalHash = leafNode;\n    while (merkelProof.length > 0) {\n      finalHash = sha256(sha256(finalHash).toString()).toString();\n      const secondLeafHash = merkelProof.shift();\n      finalHash = finalHash.concat(secondLeafHash);\n    }\n    return merkelRoot === finalHash;\n  }\n\n  async getOutpointForName(name: number[]) {\n    if (name && name.length) {\n      try {\n        const { data } = await post('allegory/name-outpoint', {\n          name,\n          isProducer: false,\n        });\n        return data;\n      } catch (error) {\n        throw error;\n      }\n    } else {\n      throw new Error('Invalid name error');\n    }\n  }\n\n  async getResellerURI(name: number[]) {\n    if (name && name.length) {\n      try {\n        const {\n          data: { forName, uri, protocol, isProducer },\n        } = await post('allegory/reseller-uri', {\n          name,\n          isProducer: true,\n        });\n        if (utils.arraysEqual(name, forName) && isProducer === true) {\n          return { isAvailable: false, name };\n        } else {\n          return { isAvailable: true, name, uri, protocol };\n        }\n      } catch (error) {\n        throw error;\n      }\n    } else {\n      throw new Error('Invalid name error');\n    }\n  }\n\n  async createTransaction(args: {\n    allpayName: string;\n    amountInSatoshi: number;\n    feeRate: number;\n  }) {\n    const { allpayName, amountInSatoshi, feeRate } = args;\n    const {\n      forName,\n      isProducer,\n      outPoint: { opTxHash, opIndex },\n      script,\n    } = await this.getOutpointForName(utils.getCodePoint(allpayName));\n    const {\n      tx: {\n        tx: { txOuts },\n      },\n    } = await transactionAPI.getTransactionByTxID(opTxHash);\n    const OP_RETURN_OUTPUT = txOuts[0];\n    const { lockingScript } = OP_RETURN_OUTPUT;\n    const allegoryData = decodeCBORData(lockingScript);\n    const allegory = getAllegoryType(allegoryData);\n    const proxyHost = '127.0.0.1';\n    const proxyPort = 8000;\n    const recipient = sha256(lockingScript).toString();\n    const { unusedAddresses } = await wallet.getUnusedAddresses();\n    const changeAddress = unusedAddresses[0];\n    const { utxos } = await Persist.getUTXOs();\n    const targets = [{ value: Number(amountInSatoshi) }];\n    let { inputs, outputs } = coinSelect(utxos, targets, feeRate);\n    if (!inputs || !outputs) throw new Error('Empty inputs or outputs');\n\n    const {\n      psaBase64,\n      addressProof,\n      utxoProof,\n    } = await this._createTransaction({\n      proxyHost,\n      proxyPort,\n      recipient,\n      amountInSatoshi,\n      changeAddress,\n      utxos: inputs,\n    });\n    const { psbt } = await this.decodeTransaction(psaBase64, inputs);\n    if (allegory && allegory.action instanceof OwnerAction) {\n      const ownerAction = allegory.action as OwnerAction;\n      if (ownerAction.oProxyProviders.length > 0) {\n        const utxoLeafNode = Buffer.from(psbt.txInputs[0].hash)\n          .reverse()\n          .toString('hex')\n          .concat(':')\n          .concat(String(psbt.txInputs[0].index));\n        const addressLeafNode = psbt.txOutputs[0].address!;\n        const addressMerkelRoot =\n          ownerAction.oProxyProviders[0].registration.addressCommitment;\n        const utxoMerkelRoot =\n          ownerAction.oProxyProviders[0].registration.utxoCommitment;\n        const addressCommitment_ = this.verifyMerkelRoot({\n          leafNode: addressLeafNode,\n          merkelRoot: addressMerkelRoot,\n          proof: addressProof,\n        });\n        const utxoCommitment_ = this.verifyMerkelRoot({\n          leafNode: utxoLeafNode,\n          merkelRoot: utxoMerkelRoot,\n          proof: utxoProof,\n        });\n\n        const addressCommitment = true;\n        const utxoCommitment = true;\n        return {\n          psbt,\n          inputs: inputs,\n          ownOutputs: [{ type: '', title: '', address: changeAddress }],\n          addressCommitment,\n          utxoCommitment,\n        };\n      }\n    }\n    throw Error('Error in drafting Allegory Transaction');\n  }\n\n  async _createTransaction(data: {\n    proxyHost: string;\n    proxyPort: number;\n    recipient: string;\n    amountInSatoshi: number;\n    changeAddress: string;\n    utxos: {\n      outputTxHash: string;\n      outputIndex: number;\n      value: number;\n    }[];\n  }): Promise<any> {\n    const {\n      proxyHost,\n      proxyPort,\n      recipient,\n      amountInSatoshi,\n      changeAddress,\n      utxos,\n    } = data;\n    const inputs = utxos.map((utxo) => {\n      return [\n        {\n          txid: utxo.outputTxHash,\n          index: utxo.outputIndex,\n        },\n        Number(utxo.value),\n      ];\n    });\n    const {\n      data: { tx: psaBase64, addressProof, utxoProof },\n    } = await post(\n      'ps-allpay-tx',\n      {\n        inputs: inputs,\n        recipient: recipient,\n        amount: Number(amountInSatoshi),\n        change: changeAddress,\n      },\n      {\n        baseURL: `http://${proxyHost}:${proxyPort}/v1`,\n      }\n    );\n    return { psaBase64, addressProof, utxoProof };\n  }\n\n  async registerName(data: {\n    proxyHost: string;\n    proxyPort: number;\n    name: string;\n    addressCount: number;\n  }) {\n    try {\n      const { proxyHost, proxyPort, name, addressCount } = data;\n      const nameCodePoint = utils.getCodePoint(name);\n      const bip32ExtendedKey = await Persist.getBip32ExtendedKey();\n      const xpubKey = wallet.getBIP32ExtendedPubKey(bip32ExtendedKey);\n      const returnAddress = await wallet.getUnusedNUTXOAddress();\n      const { nUTXOs } = await Persist.getNUtxo(name);\n      if (nUTXOs) {\n        const psaBase64 = await this._registerName({\n          proxyHost,\n          proxyPort,\n          name: nameCodePoint,\n          xpubKey,\n          returnAddress,\n          addressCount,\n          nutxo: nUTXOs,\n        });\n        const {\n          psbt,\n          fundingInputs,\n          ownOutputs,\n        } = await this.decodeTransaction(psaBase64, [nUTXOs], true);\n        return {\n          psbt,\n          inputs: [...nUTXOs, ...fundingInputs],\n          ownOutputs: [\n            { type: 'nUTXO', title: 'Name UTXO', address: returnAddress },\n            ...ownOutputs,\n          ],\n        };\n      } else {\n        throw new Error(\"Couldn't find utxo for selected name\");\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async _registerName(data: {\n    proxyHost: string;\n    proxyPort: number;\n    name: number[];\n    xpubKey: string;\n    returnAddress: string;\n    addressCount: number;\n    nutxo: {\n      outputTxHash: string;\n      outputIndex: number;\n      value: number;\n    };\n  }): Promise<any> {\n    const {\n      proxyHost,\n      proxyPort,\n      name,\n      xpubKey,\n      nutxo,\n      returnAddress,\n      addressCount,\n    } = data;\n    const nameUtxo = [\n      {\n        txid: nutxo.outputTxHash,\n        index: nutxo.outputIndex,\n      },\n      nutxo.value,\n    ];\n    const {\n      data: { tx: psaBase64 },\n    } = await post(\n      'register',\n      {\n        name: name,\n        xpubKey: xpubKey,\n        nutxo: nameUtxo,\n        return: returnAddress,\n        addressCount: Number(addressCount),\n      },\n      {\n        baseURL: `http://${proxyHost}:${proxyPort}/v1`,\n      }\n    );\n    return psaBase64;\n  }\n}\n\nexport const allPay = new Allpay();\n","import { post } from './httpClient';\n\nclass AuthAPI {\n  login = async (username: string, password: string) => {\n    try {\n      const { data } = await post('auth', { username, password });\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n}\n\nexport const authAPI = new AuthAPI();\n","import { get } from './httpClient';\nimport Qs from 'qs';\n\nclass BlockAPI {\n  getBlockByBlockHeight = async (height: number) => {\n    try {\n      const { data } = await get(`block/height/${height}`);\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  getBlocksByBlockHeights = async (heights: number[]) => {\n    try {\n      const { data } = await get(`block/heights`, {\n        params: {\n          height: heights,\n        },\n        paramsSerializer: (params) =>\n          Qs.stringify(params, { arrayFormat: 'repeat' }),\n      });\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  getBlockByBlockHash = async (blockHash: string) => {\n    try {\n      const { data } = await get(`block/hash/${blockHash}`);\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  getBlocksByBlockHashes = async (blockHashes: string[]) => {\n    try {\n      const { data } = await get(`block/hashes`, {\n        params: {\n          hash: blockHashes,\n        },\n        paramsSerializer: (params) =>\n          Qs.stringify(params, { arrayFormat: 'repeat' }),\n      });\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  getTXIDByHash = async (\n    blockHash: string,\n    pagenumber?: number,\n    pagesize?: number\n  ) => {\n    try {\n      const { data } = await get(`block/txids/${blockHash}`, {\n        params: {\n          pagenumber,\n          pagesize,\n        },\n      });\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n}\n\nexport const blockAPI = new BlockAPI();\n","import { get } from './httpClient';\n\nclass MerkleBranchAPI {\n  getMerkleBranchByTXID = async (txId: string) => {\n    try {\n      const { data } = await get(`merklebranch/${txId}`);\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n}\n\nexport const merkleBranchAPI = new MerkleBranchAPI();\n","import { get } from './httpClient';\nimport Qs from 'qs';\n\nclass ScriptHashAPI {\n  getOutputsByScriptHash = async (scriptHash: string, pagesize?: number) => {\n    try {\n      const { data } = await get(`scripthash/${scriptHash}/outputs`, {\n        params: {\n          pagesize,\n        },\n      });\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  getOutputsByScriptHashes = async (scriptHashes: string[]) => {\n    try {\n      const { data } = await get(`scripthashes/outputs/`, {\n        params: {\n          scripthash: scriptHashes,\n        },\n        paramsSerializer: (params) =>\n          Qs.stringify(params, { arrayFormat: 'repeat' }),\n      });\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  getUTXOsByScriptHash = async (scriptHash: string, pagesize?: number) => {\n    try {\n      const { data } = await get(`scripthash/${scriptHash}/utxos`, {\n        params: {\n          pagesize,\n        },\n      });\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  getUTXOsByScriptHashes = async (scriptHashes: string[]) => {\n    try {\n      const { data } = await get(`scripthashes/utxos`, {\n        params: {\n          scripthash: scriptHashes,\n        },\n        paramsSerializer: (params) =>\n          Qs.stringify(params, { arrayFormat: 'repeat' }),\n      });\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n}\n\nexport const scriptHashAPI = new ScriptHashAPI();\n","import { get, post, put, deleteR } from './httpClient';\n\nclass UserAPI {\n  addUser = async (\n    username: string,\n    firstName: string,\n    lastName: string,\n    email: string\n  ) => {\n    try {\n      const { data } = await post('user', {\n        username,\n        firstName,\n        lastName,\n        email,\n      });\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  getUser = async (username: string) => {\n    try {\n      const { data } = await get(`user/${username}`);\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  getCurrentUser = async () => {\n    try {\n      const { data } = await get('user');\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  updateUser = async (\n    username: string,\n    password: string,\n    firstName: string,\n    lastName: string,\n    email: string,\n    apiQuota: number,\n    apiExpiryTime: Date\n  ) => {\n    try {\n      const { data } = await put(`user/${username}`, {\n        data: {\n          password,\n          firstName,\n          lastName,\n          email,\n          apiQuota,\n          apiExpiryTime: apiExpiryTime.getUTCDate(),\n        },\n      });\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  deleteUser = async (username: string) => {\n    try {\n      const { data } = await deleteR(`user/${username}`);\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n}\n\nexport const userAPI = new UserAPI();\n"],"names":["BITCOIN_SV","bip32","public","private","bech32","messagePrefix","pubKeyHash","scriptHash","wif","BITCOIN_SV_REGTEST","p2wpkh","baseNetwork","p2wpkhInP2sh","p2wsh","p2wshInP2sh","BITCOIN_SV_TESTNET","BIP32","derivationPath","BIP44","purpose","coin","account","change","nUTXODerivationPath","_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","_forTo","array","body","check","reject","i","_cycle","length","_catch","recover","Symbol","iterator","asyncIterator","httpReq","get","url","config","error","post","data","put","deleteR","delete","host","port","axios","create","baseURL","httpsAgent","https","Agent","rejectUnauthorized","headers","interceptors","request","use","token","localStorage","getItem","Authorization","console","log","Promise","response","status","userName","password","sessionKey","auth","Error","setItem","resolve","Allegory","_version","_name","_action","ProducerAction","_producerInput","_producerOutput","_pOwnerOutput","_extensions","OwnerAction","_ownerInput","_ownerOutput","_oProxyProviders","Index","_index","ProducerOutput","_producer","_pVendorEndpoint","OwnerOutput","_owner","_oVendorEndpoint","OwnerExtension","_ownerOutputEx","_codePoint","ProducerExtension","_producerOutputEx","Endpoint","_protocol","_uri","ProxyProvider","_service","_mode","_endpoint","_registration","Registration","_addressCommitment","_utxoCommitment","_signature","_expiry","getAllegoryType","decodedCBOR","ownerAction","allegory","version","name","action","ownerInput","_getIndex","ownerOutput","_getOwnerOutput","oProxyProviders","map","proxyProvider","service","mode","endpoint","_getEndPoint","registration","addressCommitment","utxoCommitment","signature","expiry","_getRegistration","producerAction","producerInput","producerOutput","_getProducerOutput","pOwnerOutput","owner","oVendorEndpoint","_getVendorEndpoint","_getPOwnerOutput","extensions","datas","ownerExtension","ownerOutputEx","codePoint","_getOwnerExtension","producerExtension","producerOutputEx","_getProducerExtension","_getExtensions","_getProducerAction","index","producer","pVendorEndpoint","protocol","uri","removeOpReturn","prefixRemoved","substring","opcode","parseInt","decodeCBORData","hexData","allegoryDataBuffer","Buffer","from","allegoryDataArrayBuffer","buffer","slice","byteOffset","byteLength","CBOR","decode","profiles","db","credentials","PouchDB","plugin","MemoryAdapter","pouchdbFind","key","set","doc","prop","init","dbName","revs_limit","auto_compaction","bulkDocs","_id","createProfile","cryptedMnemonic","profileName","newProfile","existingProfiles","Array","updateProfile","currentProfileName","newProfileName","revs","profileIndex","findIndex","profile","profilesArray","_rev","getProfiles","existingProfile","login","selectedProfile","find","bip39Mnemonic","AES","decrypt","toString","CryptoJS","enc","Utf8","getBip32ExtendedKey","bip32ExtendedKeyDoc","setBip32ExtendedKey","getNUTXOExtendedKey","nUTXOExtendedKeyDoc","setNUTXOExtendedKey","getNUTXODerivedKeys","allDocs","include_docs","startkey","endkey","rows","existingNUTXODerivedKeys","row","upsertNUTXODerivedKeys","keys","keyId","docs","String","padStart","getDerivedKeys","existingDerivedKeys","upsertDerivedKeys","getOutputs","options","skip","nextOutputsCursor","id","outputs","markOutputAsUnspent","inputs","markAsUnspentOutputs","input","createIndex","fields","selector","outputTxHash","$eq","outputIndex","outputDoc","unspentOutputs","output","isSpent","push","upsertOutputs","outputId","spendInfo","deleteOutputs","deletedOutputs","deletedOutput","_deleted","isInOutputs","getTransactions","descending","nextTransactionCursor","limit","transactions","getTransactionsByConfirmations","$and","confirmation","$lte","$exists","transactionDocs","upsertTransactions","txId","reverse","transaction","deleteTransactions","updatedDoc","results","forEach","transactionDoc","markAddressesUsed","addresses","filter","includes","address","isUsed","getUTXOs","isNameOutpoint","utxos","getNUtxo","nUTXOs","getUnregisteredName","names","destroy","viewCleanup","updateDoc","element","addressAPI","pagesize","cursor","params","paramsSerializer","Qs","stringify","arrayFormat","transactionAPI","txIDs","txID","hash","rawTx","outpoint","chainAPI","startBlockHeight","bip39","seed","network","fromBase58","bip32RootKey","toBase58","bip32ExtendedKey","neutered","derivationPaths","path","codePoints","fromCodePoint","satoshi","getCodePoint","nameCodePoints","codePointAt","arraysEqual","a","b","bip32Interface","xprvkeyB58","isNeutered","_initWallet","_this2","_mnemonicToSeedSync","_getBIP32RootKeyFromSeed","_getBIP32ExtendedKey","nUTXOExtendedKey","Persist","countOfUnusedNUTXOKeys","_countOfUnusedKeys","lastKeyIndex","indexText","split","pop","generateDerivedKeys","Number","derivedKeys","countOfUnusedKeys","fromSeed","extendedKey","pathBits","bit","isNaN","deriveHardened","derive","_generateDerivedKeys","useBip38","bip38password","useHardenedAddresses","useUncompressed","keyPair","ECPair","fromPrivateKey","privateKey","compressed","payments","p2pkh","pubkey","publicKey","_getPrivKey","privkey","toWIF","indexStart","count","derivedKey","_getAddressesFromKeys","reduce","acc","currKey","_removeDuplicate","sortedOutputs","sort","output1","output2","blockHeight","unconfirmedOutputs","txIndex","uniqueOutputs","splice","self","t","processAllegoryTransactions","nameOutput","validConfirmedNamePurchaseTxs","validConfirmedNamePurchaseTx","tx","allegoryTransactions","lockingScript","startsWith","confirmedNamePurchaseTxs","allegoryTransaction","producerExtensions","extension","producerCodePoints","_producerExtensions","utils","codePointToName","confirmedNamePurchaseTx","isProducer","opTxHash","outPoint","forName","_this6","_getOutputs","newDerivedKeys","newNUTXODerivedKeys","nUTXODerivedKeys","diffOutputsWithDuplicate","diffOutputs","newKeys","spentOutputs","outgoingTxIds","Set","spendingTxId","incomingTxIds","txIds","_getTransactions","txs","getChainInfo","chainInfo","chainTip","tx1","tx2","txOuts","newTxInps","txInps","isMineAddress","isNUTXOAddress","txInputIndex","isMine","isNUTXO","newTxOuts","diff","chunkedTxIds","_","all","chunkedTxId","getTransactionsByTxIDs","flat","prevDiffOutputs","prevKeys","chunkedUsedDerivedKeys","chunkedUsedDerivedKey","_this8","_getOutputsByAddresses","outputsByAddresses","updatedKeys","found","some","newDiffOutputs","walletKeys","nUTXOKeys","nextDerivedKeys","lastNUTXOKeyIndex","nextKeys","prevOutputs","nextCursor","_this10","getOutputsByAddresses","_getDiffOutputs","newOutputs","getUnusedNUTXOAddress","existingDerivedKey","Boolean","_getKeys","KeyIndex","_this12","fromWIF","networks","regtest","updateTransactionsConfirmations","updatedTransactions","deletedTransactions","_this14","txsWithConfirmation","unconfirmedTransactions","matchedTxWithConfirmation","unconfirmedTransaction","diffInMinutes","differenceInMinutes","Date","parse","createdAt","relayTx","psbt","ownOutputs","transactionHex","toHex","base64","broadcastRawTransaction","txBroadcast","spentUtxos","changeOutputs","ownOutput","transactionOutput","outs","script","transactionIndex","getId","ins","isMineInput","inp","witnessUtxo","_psbt$data$inputs$ind","isMineOutput","type","_this16","_createSendTransaction","targets","feeRate","_this18","signInput","validateSignaturesOfAllInputs","finalizeAllInputs","extractTransaction","usedAddresses","coinSelect","Psbt","forkCoin","setVersion","addInput","addOutput","getUnusedAddresses","excludeAddresses","unusedAddresses","title","createSendTransaction","receiverAddress","amountInSatoshi","_this20","getTransactionFee","fee","getBalance","balance","currOutput","generateMnemonic","strength","rng","wordlist","getUsedAddresses","outputsGroupedByAddress","currentBalance","incomingBalance","outgoingBalance","lastTransaction","Object","entries","filteredUnusedAddresses","unusedAddress","_options$excludeAddre","profileId","_this22","cryptedText","encrypt","faker","firstName","updateProfileName","logout","runScript","allPay","buyName","paymentInputs","opIndex","wallet","outputOwner","outputChange","decodeTransaction","psaTx","snv","psaBase64","addFunding","partiallySignTransaction","JSON","updateInput","partialSig","fundingInputs","sequence","utxoInput","signRelayTransaction","psbtHex","fromHex","test","update","stage","shouldContinue","updateValue","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","txInput","txInputs","utxo","verifyRootTx","args","inputHash","outpointTxID","getTransactionByTxID","_this4","verifyMerkelRoot","merkelRoot","merkelProof","proof","finalHash","leafNode","sha256","secondLeafHash","shift","concat","getOutpointForName","getResellerURI","isAvailable","createTransaction","allpayName","recipient","changeAddress","_createTransaction","proxyHost","proxyPort","addressProof","utxoProof","utxoLeafNode","utxoMerkelRoot","txOutputs","txid","amount","registerName","addressCount","nameCodePoint","xpubKey","getBIP32ExtendedPubKey","returnAddress","_registerName","nutxo","return","authAPI","username","blockAPI","height","heights","blockHash","blockHashes","pagenumber","merkleBranchAPI","scriptHashAPI","scriptHashes","scripthash","userAPI","lastName","email","apiQuota","apiExpiryTime","getUTCDate"],"mappings":"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"}