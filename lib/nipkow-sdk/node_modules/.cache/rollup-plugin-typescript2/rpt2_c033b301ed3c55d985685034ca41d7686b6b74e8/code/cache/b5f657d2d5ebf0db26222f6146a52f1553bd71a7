{"code":"import { bip32, ECPair, networks, payments, Psbt, } from 'bitcoinjs-lib';\r\nimport AES from 'crypto-js/aes';\r\nimport coinSelect from 'coinselect';\r\nimport faker from 'faker';\r\nimport * as bip38 from 'bip38';\r\nimport * as bip39 from 'bip39';\r\nimport * as _ from 'lodash';\r\n// import { differenceInMinutes } from 'date-fns';\r\nimport * as Persist from './Persist';\r\nimport derivationPaths from './constants/derivationPaths';\r\nimport network from './constants/network';\r\nimport { addressAPI } from './AddressAPI';\r\nimport { transactionAPI } from './TransactionAPI';\r\nimport { chainAPI } from './ChainAPI';\r\nclass Wallet {\r\n    async _initWallet(bip39Mnemonic, password) {\r\n        const seed = this._mnemonicToSeedSync(bip39Mnemonic, password);\r\n        const bip32RootKey = this._getBIP32RootKeyFromSeed(seed, network.BITCOIN_SV_REGTEST);\r\n        const bip32ExtendedKey = this._getBIP32ExtendedKey(derivationPaths.BITCOIN_SV_REGTEST.BIP44.derivationPath, bip32RootKey);\r\n        await Persist.setBip32ExtendedKey(bip32ExtendedKey);\r\n        const { existingDerivedKeys } = await Persist.getDerivedKeys();\r\n        const countOfUnusedKeys = this._countOfUnusedKeys(existingDerivedKeys);\r\n        if (countOfUnusedKeys < 20) {\r\n            let lastKeyIndex = -1;\r\n            if (existingDerivedKeys.length > 0) {\r\n                lastKeyIndex = existingDerivedKeys[existingDerivedKeys.length - 1].indexText\r\n                    .split('/')\r\n                    .pop();\r\n            }\r\n            const { derivedKeys: newDerivedKeys } = await this._generateDerivedKeys(bip32ExtendedKey, Number(lastKeyIndex) + 1, 20 - countOfUnusedKeys, false);\r\n            await Persist.upsertDerivedKeys(newDerivedKeys);\r\n        }\r\n    }\r\n    _mnemonicToSeedSync(bip39Mnemonic, password) {\r\n        return bip39.mnemonicToSeedSync(bip39Mnemonic, password);\r\n    }\r\n    _getBIP32RootKeyFromSeed(seed, network) {\r\n        return bip32.fromSeed(seed, network).toBase58();\r\n    }\r\n    _getBIP32ExtendedKey(path, bip32RootKey) {\r\n        if (!bip32RootKey) {\r\n            return bip32RootKey;\r\n        }\r\n        let extendedKey = bip32.fromBase58(bip32RootKey, network.BITCOIN_SV_REGTEST);\r\n        const pathBits = path.split('/');\r\n        for (let i = 0; i < pathBits.length; i++) {\r\n            const bit = pathBits[i];\r\n            const index = parseInt(bit);\r\n            if (isNaN(index)) {\r\n                continue;\r\n            }\r\n            const hardened = bit[bit.length - 1] === \"'\";\r\n            if (hardened) {\r\n                extendedKey = extendedKey.deriveHardened(index);\r\n            }\r\n            else {\r\n                extendedKey = extendedKey.derive(index);\r\n            }\r\n        }\r\n        return extendedKey.toBase58();\r\n    }\r\n    _generateDerivedAddress(bip32ExtendedKey, index, useBip38, bip38password = '', useHardenedAddresses) {\r\n        const bip32Interface = bip32.fromBase58(bip32ExtendedKey, network.BITCOIN_SV_REGTEST);\r\n        let key;\r\n        if (useHardenedAddresses) {\r\n            key = bip32Interface.deriveHardened(index);\r\n        }\r\n        else {\r\n            key = bip32Interface.derive(index);\r\n        }\r\n        const useUncompressed = useBip38;\r\n        let keyPair = ECPair.fromPrivateKey(key.privateKey, {\r\n            network: network.BITCOIN_SV_REGTEST,\r\n        });\r\n        if (useUncompressed) {\r\n            keyPair = ECPair.fromPrivateKey(key.privateKey, {\r\n                compressed: false,\r\n                network: network.BITCOIN_SV_REGTEST,\r\n            });\r\n        }\r\n        const address = payments.p2pkh({\r\n            pubkey: keyPair.publicKey,\r\n            network: network.BITCOIN_SV_REGTEST,\r\n        }).address;\r\n        let indexText = derivationPaths.BITCOIN_SV_REGTEST.BIP44.derivationPath + '/' + index;\r\n        if (useHardenedAddresses) {\r\n            indexText = indexText + \"'\";\r\n        }\r\n        return { indexText, address };\r\n    }\r\n    _getPrivKey(bip32ExtendedKey, index, useBip38, bip38password = '', useHardenedAddresses) {\r\n        const bip32Interface = bip32.fromBase58(bip32ExtendedKey, network.BITCOIN_SV_REGTEST);\r\n        let key;\r\n        if (useHardenedAddresses) {\r\n            key = bip32Interface.deriveHardened(index);\r\n        }\r\n        else {\r\n            key = bip32Interface.derive(index);\r\n        }\r\n        const useUncompressed = useBip38;\r\n        let keyPair = ECPair.fromPrivateKey(key.privateKey, {\r\n            network: network.BITCOIN_SV_REGTEST,\r\n        });\r\n        if (useUncompressed) {\r\n            keyPair = ECPair.fromPrivateKey(key.privateKey, {\r\n                compressed: false,\r\n                network: network.BITCOIN_SV_REGTEST,\r\n            });\r\n        }\r\n        // const address = payments.p2pkh({\r\n        //   pubkey: keyPair.publicKey,\r\n        //   network: network.BITCOIN_SV_REGTEST,\r\n        // }).address!;\r\n        const hasPrivkey = !key.isNeutered();\r\n        let privkey = '';\r\n        if (hasPrivkey) {\r\n            privkey = keyPair.toWIF();\r\n            if (useBip38) {\r\n                privkey = bip38.encrypt(keyPair.privateKey, false, bip38password);\r\n            }\r\n        }\r\n        // const pubkey = keyPair.publicKey.toString('hex');\r\n        // let indexText =\r\n        //   derivationPaths.BITCOIN_SV_REGTEST.BIP44.derivationPath + '/' + index;\r\n        // if (useHardenedAddresses) {\r\n        //   indexText = indexText + \"'\";\r\n        // }\r\n        // if (index === 0) {\r\n        //   return {\r\n        //     privkey: 'cTP23waCMwbWfDoH53PGJNpbyiyMk2g2djhuXff5XhPNuewqdKNY',\r\n        //   };\r\n        // }\r\n        return { privkey };\r\n    }\r\n    async _generateDerivedKeys(bip32ExtendedKey, indexStart, count, useBip38, bip38password, useHardenedAddresses) {\r\n        const derivedKeys = [];\r\n        for (let i = indexStart; i < indexStart + count; i++) {\r\n            // if (i === 0) {\r\n            //   const derivedKey = { address: '', indexText: 'm/44/1/0/0/0' };\r\n            //   derivedKey.address = 'mkTJA5GAsJQp7UmAgh43AVAVM4BvjWbG7z';\r\n            // derivedKey.privkey =\r\n            // 'cTP23waCMwbWfDoH53PGJNpbyiyMk2g2djhuXff5XhPNuewqdKNY';\r\n            // derivedKey.address = 'mmKu1EzwGmicQA5XwpFVDBegwNjf7h55MP';\r\n            // derivedKey.privkey =\r\n            //   'cSn2zVDF4c7w63rH1Cc2uXsMr6UzFAwasTRmm4CpQet1ofuVKzRj';\r\n            //   derivedKeys.push({ ...derivedKey, isUsed: false });\r\n            // } else {\r\n            const derivedKey = this._generateDerivedAddress(bip32ExtendedKey, i, useBip38, bip38password, useHardenedAddresses);\r\n            derivedKeys.push({ ...derivedKey, isUsed: false });\r\n            // }\r\n        }\r\n        return { derivedKeys };\r\n    }\r\n    _getAddressesFromKeys(derivedKeys) {\r\n        return derivedKeys.map((key) => key.address);\r\n    }\r\n    async getTransaction(txid) {\r\n        try {\r\n            return await transactionAPI.getTransactionByTxID(txid);\r\n        }\r\n        catch (error) {\r\n            throw error;\r\n        }\r\n    }\r\n    _countOfUnusedKeys(keys) {\r\n        return keys.reduce((acc, currKey) => {\r\n            if (!currKey.isUsed) {\r\n                acc = acc + 1;\r\n            }\r\n            return acc;\r\n        }, 0);\r\n    }\r\n    async getTransactions(options) {\r\n        const { existingDerivedKeys } = await Persist.getDerivedKeys();\r\n        if (existingDerivedKeys.length > 0) {\r\n            const { derivedKeys: newDerivedKeys, diffOutputs, } = await this._getOutputs(existingDerivedKeys);\r\n            if (diffOutputs.length > 0) {\r\n                const spentOutputs = diffOutputs.filter((output) => {\r\n                    if (output.spendInfo)\r\n                        return true;\r\n                    return false;\r\n                });\r\n                const outgoingTxIds = Array.from(new Set(spentOutputs.map((output) => output.spendInfo.spendingTxId)));\r\n                const incomingTxIds = Array.from(new Set(diffOutputs.map((output) => output.outputTxHash)));\r\n                const txIds = Array.from(new Set([...incomingTxIds, ...outgoingTxIds]));\r\n                const { txs } = await this._getTransactions(txIds);\r\n                // const { txs } = await transactionAPI.getTransactionsByTxIDs(txIds);\r\n                const { chainInfo } = await chainAPI.getChainInfo();\r\n                if (chainInfo) {\r\n                    const { chainTip } = chainInfo;\r\n                    if (txs.length > 0) {\r\n                        const sortedTx = txs.sort((tx1, tx2) => {\r\n                            return tx2.blockHeight - tx1.blockHeight;\r\n                        });\r\n                        const transactions = sortedTx.map((transaction) => {\r\n                            const { tx: { txInps, txOuts }, blockHeight, } = transaction;\r\n                            const newTxInps = txInps.map((input) => {\r\n                                const isMineAddress = newDerivedKeys.find((derivedKey) => derivedKey.address === input.address);\r\n                                return {\r\n                                    address: input.address,\r\n                                    txInputIndex: input.txInputIndex,\r\n                                    value: input.value,\r\n                                    isMine: isMineAddress ? true : false,\r\n                                };\r\n                            });\r\n                            const newTxOuts = txOuts.map((output) => {\r\n                                const isMineAddress = newDerivedKeys.find((derivedKey) => derivedKey.address === output.address);\r\n                                return {\r\n                                    address: output.address,\r\n                                    outputIndex: output.outputIndex,\r\n                                    value: output.value,\r\n                                    isMine: isMineAddress ? true : false,\r\n                                };\r\n                            });\r\n                            const newTransaction = {\r\n                                txId: transaction.txId,\r\n                                inputs: newTxInps,\r\n                                outputs: newTxOuts,\r\n                            };\r\n                            return {\r\n                                ...newTransaction,\r\n                                confirmations: blockHeight\r\n                                    ? chainTip - blockHeight\r\n                                    : undefined,\r\n                            };\r\n                        });\r\n                        let confirmedTxs = [];\r\n                        let unConfirmedTxs = [];\r\n                        transactions.forEach((transaction) => {\r\n                            if (transaction.confirmations >= 0) {\r\n                                confirmedTxs.push(transaction);\r\n                            }\r\n                            else {\r\n                                unConfirmedTxs.push(transaction);\r\n                            }\r\n                        });\r\n                        await Persist.upsertOutputs(diffOutputs);\r\n                        await Persist.upsertTransactions(confirmedTxs);\r\n                        await Persist.upsertUnconfirmedTransactions(unConfirmedTxs);\r\n                        await Persist.upsertDerivedKeys(newDerivedKeys);\r\n                        if (options?.diff) {\r\n                            return { transactions };\r\n                        }\r\n                        else {\r\n                            return await Persist.getTransactions(options);\r\n                        }\r\n                    }\r\n                    else {\r\n                        throw new Error('Error in fetching transactions');\r\n                    }\r\n                }\r\n                else {\r\n                    throw new Error('Error in fetching transactions');\r\n                }\r\n            }\r\n            else {\r\n                if (options?.diff) {\r\n                    return { transactions: [] };\r\n                }\r\n                else {\r\n                    return await Persist.getTransactions(options);\r\n                }\r\n            }\r\n        }\r\n        return { transactions: [] };\r\n    }\r\n    async _getTransactions(txIds) {\r\n        const chunkedTxIds = _.chunk(txIds, 20);\r\n        const data = await Promise.all(chunkedTxIds.map(async (chunkedTxId) => {\r\n            return await transactionAPI.getTransactionsByTxIDs(chunkedTxId);\r\n        }));\r\n        const transactions = data.map((element) => element.txs).flat();\r\n        return { txs: transactions };\r\n    }\r\n    // async getOutputs(options?: {\r\n    //   startkey?: string;\r\n    //   limit?: number;\r\n    //   pageNo?: number;\r\n    //   diff?: boolean;\r\n    // }) {\r\n    //   const { existingDerivedKeys } = await Persist.getDerivedKeys();\r\n    //   if (existingDerivedKeys.length > 0) {\r\n    //     const {\r\n    //       derivedKeys: newDerivedKeys,\r\n    //       diffOutputs,\r\n    //     } = await this._getOutputs(existingDerivedKeys);\r\n    //     if (diffOutputs.length > 0) {\r\n    //       const outputsGroupedByTx = _.groupBy(diffOutputs, (output) => {\r\n    //         return output.outputTxHash;\r\n    //       });\r\n    //       const diffTrasactions = Object.entries(outputsGroupedByTx).map(\r\n    //         ([key, value], index) => {\r\n    //           return {\r\n    //             txId: key,\r\n    //             confirmed: true,\r\n    //             outputs: value,\r\n    //           };\r\n    //         }\r\n    //       );\r\n    //       await Persist.upsertOutputs(diffOutputs);\r\n    //       await Persist.upsertTransactions(diffTrasactions);\r\n    //       await Persist.upsertDerivedKeys(newDerivedKeys);\r\n    //     }\r\n    //     if (options?.diff) {\r\n    //       return { outputs: diffOutputs };\r\n    //     } else {\r\n    //       return await Persist.getOutputs(options);\r\n    //     }\r\n    //   }\r\n    //   return { outputs: [] };\r\n    // }\r\n    async _getOutputs(derivedKeys, prevOutputs = [], prevDiffOutputs = [], prevKeys = []) {\r\n        const chunkedUsedDerivedKeys = _.chunk(derivedKeys, 20);\r\n        const data = await Promise.all(chunkedUsedDerivedKeys.map(async (chunkedUsedDerivedKey) => {\r\n            return await this._getOutputsByAddresses(chunkedUsedDerivedKey);\r\n        }));\r\n        const outputs = data.flat();\r\n        const diffOutputs = await this._getDiffOutputs(outputs);\r\n        const updatedKeys = derivedKeys.map((key) => {\r\n            if (!key.isUsed) {\r\n                const found = outputs.some((output) => output.address === key.address);\r\n                return { ...key, isUsed: found };\r\n            }\r\n            return key;\r\n        });\r\n        const newOutputs = [...prevOutputs, ...outputs];\r\n        const newDiffOutputs = [...prevDiffOutputs, ...diffOutputs];\r\n        const newKeys = [...prevKeys, ...updatedKeys];\r\n        const countOfUnusedKeys = this._countOfUnusedKeys(newKeys);\r\n        if (countOfUnusedKeys < 20) {\r\n            const bip32ExtendedKey = await Persist.getBip32ExtendedKey();\r\n            const lastKeyIndex = derivedKeys[derivedKeys.length - 1].indexText\r\n                .split('/')\r\n                .pop();\r\n            const { derivedKeys: nextDerivedKeys } = await this._generateDerivedKeys(bip32ExtendedKey, Number(lastKeyIndex) + 1, 20 - countOfUnusedKeys, false);\r\n            return await this._getOutputs(nextDerivedKeys, newOutputs, newDiffOutputs, newKeys);\r\n        }\r\n        else {\r\n            return {\r\n                outputs: newOutputs,\r\n                diffOutputs: newDiffOutputs,\r\n                derivedKeys: newKeys,\r\n            };\r\n        }\r\n    }\r\n    async _getOutputsByAddresses(keys, prevOutputs = [], nextCursor) {\r\n        const addresses = this._getAddressesFromKeys(keys);\r\n        const data = await addressAPI.getOutputsByAddresses(addresses, 100, nextCursor);\r\n        const { lastFetched } = await Persist.getOutputsLastFetched();\r\n        if (lastFetched) {\r\n            const diffOutputs = await this._getDiffOutputs(data.outputs);\r\n            if (diffOutputs.length === data.outputs.length) {\r\n                const outputs = [...prevOutputs, ...diffOutputs];\r\n                if (data.nextCursor) {\r\n                    return await this._getOutputsByAddresses(keys, outputs, data.nextCursor);\r\n                }\r\n                else {\r\n                    return outputs;\r\n                }\r\n            }\r\n            else {\r\n                return diffOutputs;\r\n            }\r\n        }\r\n        else {\r\n            const outputs = [...prevOutputs, ...data.outputs];\r\n            if (data.nextCursor) {\r\n                return await this._getOutputsByAddresses(keys, outputs, data.nextCursor);\r\n            }\r\n            else {\r\n                return outputs;\r\n            }\r\n        }\r\n    }\r\n    async _getDiffOutputs(outputs) {\r\n        const newOutputs = [];\r\n        for (let index = 0; index < outputs.length; index++) {\r\n            if (!(await Persist.isInOutputs(outputs[index]))) {\r\n                newOutputs.push(outputs[index]);\r\n            }\r\n            else {\r\n                return newOutputs;\r\n            }\r\n        }\r\n        return newOutputs;\r\n    }\r\n    async updateconfirmations() {\r\n        // const {\r\n        //   unconfirmedTransactions,\r\n        // } = await Persist.getUnconfirmedTransactions();\r\n        // const unconfirmedTxIds = unconfirmedTransactions.map(\r\n        //   (unconfirmedTx: { txId: any }) => unconfirmedTx.txId\r\n        // );\r\n        // if (unconfirmedTxIds.length > 0) {\r\n        //   const { txs } = await transactionAPI.getTransactionsByTxIDs(\r\n        //     unconfirmedTxIds\r\n        //   );\r\n        //   if (txs.length > 0) {\r\n        //     const updatedUnconfirmedTransactions = unconfirmedTransactions.map(\r\n        //       (unconfirmedTx: { txId: any }) => {\r\n        //         const isConfirmed = txs.find(\r\n        //           (tx: { txId: any; blockHeight: number }) => {\r\n        //             if (tx.blockHeight && tx.txId === unconfirmedTx.txId) {\r\n        //               return true;\r\n        //             }\r\n        //             return false;\r\n        //           }\r\n        //         );\r\n        //         if (isConfirmed) {\r\n        //           return {\r\n        //             ...unconfirmedTx,\r\n        //             confirmed: true,\r\n        //           };\r\n        //         }\r\n        //         return {\r\n        //           ...unconfirmedTx,\r\n        //           confirmed: false,\r\n        //         };\r\n        //       }\r\n        //     );\r\n        //     const confirmedTxs = updatedUnconfirmedTransactions.filter(\r\n        //       (tx: { confirmed: boolean }) => tx.confirmed === true\r\n        //     );\r\n        //     if (confirmedTxs.length > 0) {\r\n        //       const confirmedOutputsPerTx = confirmedTxs.map(\r\n        //         (confirmedTx: { outputs: any }) => confirmedTx.outputs\r\n        //       );\r\n        //       const confirmedOutputs = confirmedOutputsPerTx.flat();\r\n        //       const updatedConfirmedOutputs = confirmedOutputs.map(\r\n        //         (output: any) => ({\r\n        //           ...output,\r\n        //           confirmed: true,\r\n        //         })\r\n        //       );\r\n        //       await Persist.updateOutputs(updatedConfirmedOutputs);\r\n        //       await Persist.deleteUnconfirmedTx(confirmedTxs);\r\n        //     }\r\n        //   }\r\n        // }\r\n    }\r\n    async updateUnconfirmedTransactions() {\r\n        const { unconfirmedTransactions, } = await Persist.getUnconfirmedTransactions();\r\n        const unconfirmedTxIds = unconfirmedTransactions.map((unconfirmedTx) => unconfirmedTx.txId);\r\n        if (unconfirmedTxIds.length > 0) {\r\n            const { txs } = await transactionAPI.getTransactionsByTxIDs(unconfirmedTxIds);\r\n            if (txs.length > 0) {\r\n                const updatedUnconfirmedTransactions = unconfirmedTransactions.map((unconfirmedTx) => {\r\n                    const isConfirmed = txs.find((tx) => {\r\n                        if (tx.blockHeight && tx.txId === unconfirmedTx.txId) {\r\n                            return true;\r\n                        }\r\n                        return false;\r\n                    });\r\n                    if (isConfirmed) {\r\n                        return {\r\n                            ...unconfirmedTx,\r\n                            confirmed: true,\r\n                        };\r\n                    }\r\n                    return {\r\n                        ...unconfirmedTx,\r\n                        confirmed: false,\r\n                    };\r\n                });\r\n                const confirmedTxs = updatedUnconfirmedTransactions.filter((tx) => tx.confirmed === true);\r\n                if (confirmedTxs.length > 0) {\r\n                    const confirmedOutputsPerTx = confirmedTxs.map((confirmedTx) => confirmedTx.outputs);\r\n                    const confirmedOutputs = confirmedOutputsPerTx.flat();\r\n                    const updatedConfirmedOutputs = confirmedOutputs.map((output) => ({\r\n                        ...output,\r\n                        confirmed: true,\r\n                    }));\r\n                    await Persist.updateOutputs(updatedConfirmedOutputs);\r\n                    await Persist.deleteUnconfirmedTx(confirmedTxs);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // async getUTXOs() {\r\n    //   const { existingDerivedKeys } = await Persist.getDerivedKeys();\r\n    //   if (existingDerivedKeys.length > 0) {\r\n    //     const { derivedKeys: newDerivedKeys, diffUTXOs } = await this._getUTXOs(\r\n    //       existingDerivedKeys\r\n    //     );\r\n    //     if (diffUTXOs.length > 0) {\r\n    //       const { lastUpdated } = await Persist.getOutputsLastUpdated();\r\n    //       const newDiffUtxos = [];\r\n    //       for (let index = 0; index < diffUTXOs.length; index++) {\r\n    //         const { isPresent, _id, _rev } = await Persist.isInOutputsNew(\r\n    //           diffUTXOs[index]\r\n    //         );\r\n    //         if (!isPresent) {\r\n    //           newDiffUtxos.push({ ...diffUTXOs[index], isSpent: false });\r\n    //         } else {\r\n    //           const diffInMinutes = differenceInMinutes(\r\n    //             new Date(),\r\n    //             Date.parse(lastUpdated)\r\n    //           );\r\n    //           if (diffInMinutes > 30) {\r\n    //             newDiffUtxos.push({\r\n    //               ...diffUTXOs[index],\r\n    //               _id,\r\n    //               _rev,\r\n    //               isSpent: false,\r\n    //             });\r\n    //           }\r\n    //         }\r\n    //       }\r\n    //       if (newDiffUtxos.length > 0) {\r\n    //         await Persist.upsertDerivedKeys(newDerivedKeys);\r\n    //         await Persist.updateOutputs(newDiffUtxos);\r\n    //       }\r\n    //     }\r\n    //   }\r\n    // }\r\n    // async _getUTXOs(\r\n    //   derivedKeys: any[],\r\n    //   prevUtxos: any[] = [],\r\n    //   prevDiffUtxos: any[] = [],\r\n    //   prevKeys: any[] = []\r\n    // ): Promise<any> {\r\n    //   const chunkedUsedDerivedKeys = _.chunk(derivedKeys, 20);\r\n    //   const data = await Promise.all(\r\n    //     chunkedUsedDerivedKeys.map(async (chunkedUsedDerivedKey) => {\r\n    //       return await this._getUTXOsByAddresses(chunkedUsedDerivedKey);\r\n    //     })\r\n    //   );\r\n    //   const utxos = data.flat();\r\n    //   const diffUTXOs = await this._getDiffUTXOs(utxos);\r\n    //   const updatedKeys = derivedKeys.map(\r\n    //     (key: { address: string; indexText: string; isUsed: boolean }) => {\r\n    //       if (!key.isUsed) {\r\n    //         const found = utxos.some(\r\n    //           (utxo: { address: any }) => utxo.address === key.address\r\n    //         );\r\n    //         return { ...key, isUsed: found };\r\n    //       }\r\n    //       return key;\r\n    //     }\r\n    //   );\r\n    //   const newUtxos = [...prevUtxos, ...utxos];\r\n    //   const newDiffUtxos = [...prevDiffUtxos, ...diffUTXOs];\r\n    //   const newKeys = [...prevKeys, ...updatedKeys];\r\n    //   const countOfUnusedKeys = this._countOfUnusedKeys(newKeys);\r\n    //   if (countOfUnusedKeys < 20) {\r\n    //     const bip32ExtendedKey = await Persist.getBip32ExtendedKey();\r\n    //     const lastKeyIndex = derivedKeys[derivedKeys.length - 1].indexText\r\n    //       .split('/')\r\n    //       .pop();\r\n    //     const { derivedKeys: nextDerivedKeys } = await this._generateDerivedKeys(\r\n    //       bip32ExtendedKey,\r\n    //       Number(lastKeyIndex) + 1,\r\n    //       20 - countOfUnusedKeys,\r\n    //       false\r\n    //     );\r\n    //     return await this._getUTXOs(\r\n    //       nextDerivedKeys,\r\n    //       newUtxos,\r\n    //       newDiffUtxos,\r\n    //       newKeys\r\n    //     );\r\n    //   } else {\r\n    //     return {\r\n    //       utxos: newUtxos,\r\n    //       diffUTXOs: newDiffUtxos,\r\n    //       derivedKeys: newKeys,\r\n    //     };\r\n    //   }\r\n    // }\r\n    // async _getUTXOsByAddresses(\r\n    //   keys: any[],\r\n    //   prevUtxos: any[] = [],\r\n    //   nextCursor?: number\r\n    // ): Promise<any> {\r\n    //   const addresses = this._getAddressesFromKeys(keys);\r\n    //   const data: {\r\n    //     utxos: any[];\r\n    //     nextCursor: number;\r\n    //   } = await addressAPI.getUTXOsByAddresses(addresses, 100, nextCursor);\r\n    //   const { lastFetched } = await Persist.getOutputsLastFetched();\r\n    //   if (lastFetched) {\r\n    //     const diffUTXOs = await this._getDiffUTXOs(data.utxos);\r\n    //     if (diffUTXOs.length === data.utxos.length) {\r\n    //       const utxos = [...prevUtxos, ...diffUTXOs];\r\n    //       if (data.nextCursor) {\r\n    //         return await this._getUTXOsByAddresses(keys, utxos, data.nextCursor);\r\n    //       } else {\r\n    //         return utxos;\r\n    //       }\r\n    //     } else {\r\n    //       return diffUTXOs;\r\n    //     }\r\n    //   } else {\r\n    //     const utxos = [...prevUtxos, ...data.utxos];\r\n    //     if (data.nextCursor) {\r\n    //       return await this._getUTXOsByAddresses(keys, utxos, data.nextCursor);\r\n    //     } else {\r\n    //       return utxos;\r\n    //     }\r\n    //   }\r\n    // }\r\n    // async _getDiffUTXOs(utxos: any[]) {\r\n    //   const newUTXOs: any[] = [];\r\n    //   for (let index = 0; index < utxos.length; index++) {\r\n    //     if (!(await Persist.isInUTXOs(utxos[index]))) {\r\n    //       newUTXOs.push(utxos[index]);\r\n    //     } else {\r\n    //       return newUTXOs;\r\n    //     }\r\n    //   }\r\n    //   return newUTXOs;\r\n    // }\r\n    async _getChangeAddress() {\r\n        const { existingDerivedKeys } = await Persist.getDerivedKeys();\r\n        const ununsedKeyIndex = existingDerivedKeys.findIndex((derivedKey) => derivedKey.isUsed === false);\r\n        const newDerivedKeys = [...existingDerivedKeys];\r\n        newDerivedKeys[ununsedKeyIndex] = {\r\n            ...newDerivedKeys[ununsedKeyIndex],\r\n            isUsed: true,\r\n        };\r\n        Persist.upsertDerivedKeys(newDerivedKeys);\r\n        return newDerivedKeys[ununsedKeyIndex].address;\r\n    }\r\n    async _getKeys(addresses) {\r\n        const { existingDerivedKeys } = await Persist.getDerivedKeys();\r\n        const bip32ExtendedKey = await Persist.getBip32ExtendedKey();\r\n        return addresses.map((address) => {\r\n            const derivedKey = existingDerivedKeys.find((derivedKey) => derivedKey.address === address);\r\n            const KeyIndex = derivedKey.indexText.split('/').pop();\r\n            const { privkey } = this._getPrivKey(bip32ExtendedKey, Number(KeyIndex), false);\r\n            return ECPair.fromWIF(privkey, networks.regtest);\r\n            /*\r\n            return ECPair.fromWIF(\r\n              'cVi5XGpCSSooYdVreWzTHJHg1cAW1q2Hu9MK64jEsBobYBbfpFBi',\r\n              networks.regtest\r\n            );*/\r\n        });\r\n    }\r\n    async _createSendTransaction(utxos, targets, feeRate) {\r\n        try {\r\n            // let feeRate = 5; // satoshis per byte\r\n            // if (transactionFee === 0) {\r\n            //   feeRate = 0;\r\n            // }\r\n            let { inputs, outputs } = coinSelect(utxos, targets, feeRate);\r\n            if (!inputs || !outputs)\r\n                throw new Error('Empty inputs or outputs');\r\n            // if (transactionFee !== fee) {\r\n            //   const changeOutputs = outputs.filter((output: { address: any }) => {\r\n            //     if (!output.address) return true;\r\n            //     return false;\r\n            //   });\r\n            //   const diffFee = fee - transactionFee;\r\n            //   if (changeOutputs.length > 0) {\r\n            //     changeOutputs[0].value = Number(changeOutputs[0].value) + diffFee;\r\n            //   }\r\n            // }\r\n            const txIds = inputs.map((input) => input.outputTxHash);\r\n            const rawTxsResponse = await transactionAPI.getRawTransactionsByTxIDs(txIds);\r\n            const inputsWithRawTxs = rawTxsResponse.rawTxs.map((rawTx) => {\r\n                const hex = Buffer.from(rawTx.txSerialized, 'base64').toString('hex');\r\n                return { ...rawTx, hex };\r\n            });\r\n            let merged = [];\r\n            for (let i = 0; i < inputs.length; i++) {\r\n                merged.push({\r\n                    ...inputs[i],\r\n                    ...inputsWithRawTxs.find((element) => element.txId === inputs[i].outputTxHash),\r\n                });\r\n            }\r\n            const psbt = new Psbt({\r\n                network: network.BITCOIN_SV_REGTEST,\r\n                forkCoin: 'bch',\r\n            });\r\n            psbt.setVersion(1);\r\n            merged.forEach((input) => {\r\n                psbt.addInput({\r\n                    hash: input.outputTxHash,\r\n                    index: input.outputIndex,\r\n                    nonWitnessUtxo: Buffer.from(input.hex, 'hex'),\r\n                });\r\n            });\r\n            for (let index = 0; index < outputs.length; index++) {\r\n                const output = outputs[index];\r\n                if (!output.address) {\r\n                    output.address = await this._getChangeAddress();\r\n                }\r\n                psbt.addOutput({\r\n                    address: output.address,\r\n                    value: output.value,\r\n                });\r\n            }\r\n            const addresses = merged.map((input) => input.address);\r\n            const keys = await this._getKeys(addresses);\r\n            keys.forEach((key, i) => {\r\n                psbt.signInput(i, key);\r\n            });\r\n            psbt.validateSignaturesOfAllInputs();\r\n            psbt.finalizeAllInputs();\r\n            const transaction = psbt.extractTransaction(true);\r\n            const transactionHex = transaction.toHex();\r\n            const base64 = Buffer.from(transactionHex, 'hex').toString('base64');\r\n            // const { txBroadcast } = await transactionAPI.broadcastRawTransaction(\r\n            //   base64\r\n            // );\r\n            // if (txBroadcast) {\r\n            //   const spentUtxos = inputs.map((input: any) => ({\r\n            //     ...input,\r\n            //     isSpent: true,\r\n            //     confirmed: false,\r\n            //   }));\r\n            //   await Persist.updateOutputs(spentUtxos);\r\n            //   await Persist.upsertUnconfirmedTransactions([\r\n            //     {\r\n            //       txId: transaction.getId(),\r\n            //       confirmed: false,\r\n            //       outputs: spentUtxos,\r\n            //       createdAt: new Date(),\r\n            //     },\r\n            //   ]);\r\n            // }\r\n        }\r\n        catch (error) {\r\n            throw error;\r\n        }\r\n    }\r\n    async createSendTransaction(receiverAddress, amountInSatoshi, feeRate) {\r\n        const { utxos } = await Persist.getUTXOs();\r\n        const targets = [\r\n            { address: receiverAddress, value: Number(amountInSatoshi) },\r\n        ];\r\n        await this._createSendTransaction(utxos, targets, feeRate);\r\n    }\r\n    async getTransactionFee(receiverAddress, amountInSatoshi, feeRate) {\r\n        try {\r\n            const { utxos } = await Persist.getUTXOs();\r\n            const targets = [\r\n                { address: receiverAddress, value: Number(amountInSatoshi) },\r\n            ];\r\n            let { fee } = coinSelect(utxos, targets, feeRate);\r\n            // if (!inputs) throw new Error('Not sufficient funds');\r\n            // if (!outputs) throw new Error('No Receiver specified');\r\n            return fee;\r\n        }\r\n        catch (error) {\r\n            throw error;\r\n        }\r\n    }\r\n    async getBalance() {\r\n        const { outputs } = await Persist.getOutputs();\r\n        const balance = outputs.reduce((acc, currOutput) => {\r\n            if (!currOutput.isSpent) {\r\n                acc = acc + currOutput.value;\r\n            }\r\n            return acc;\r\n        }, 0);\r\n        return { balance };\r\n    }\r\n    generateMnemonic(strength, rng, wordlist) {\r\n        return bip39.generateMnemonic(strength, rng, wordlist);\r\n    }\r\n    async getUsedDerivedKeys() {\r\n        const { outputs } = await Persist.getOutputs();\r\n        const outputsGroupedByAddress = _.groupBy(outputs, (output) => {\r\n            return output.address;\r\n        });\r\n        const usedDerivedKeys = [];\r\n        for (const [address, outputs] of Object.entries(outputsGroupedByAddress)) {\r\n            const currentBalance = outputs.reduce((acc, currOutput) => {\r\n                if (!currOutput.spendInfo) {\r\n                    acc = acc + currOutput.value;\r\n                }\r\n                return acc;\r\n            }, 0);\r\n            let incomingBalance = 0;\r\n            let outgoingBalance = 0;\r\n            outputs.forEach((output) => {\r\n                if (output.spendInfo) {\r\n                    outgoingBalance = outgoingBalance + output.value;\r\n                }\r\n                incomingBalance = incomingBalance + output.value;\r\n            });\r\n            usedDerivedKeys.push({\r\n                address,\r\n                incomingBalance,\r\n                outgoingBalance,\r\n                currentBalance,\r\n                lastTransaction: outputs[0].address,\r\n            });\r\n        }\r\n        return {\r\n            usedDerivedKeys,\r\n        };\r\n    }\r\n    async getUnusedDerivedKeys(options) {\r\n        const { existingDerivedKeys } = await Persist.getDerivedKeys();\r\n        const unusedDerivedKeys = existingDerivedKeys\r\n            .filter((existingDerivedKey) => existingDerivedKey.isUsed === false)\r\n            .map(({ indexText, address }) => ({\r\n            indexText,\r\n            address,\r\n        }));\r\n        if (options?.currentUnusedKeyIndex) {\r\n            const currentUnusedKeyIndex = options.currentUnusedKeyIndex;\r\n            const nextUnusedDerivedKeys = unusedDerivedKeys.filter((existingDerivedKey) => existingDerivedKey.indexText !== currentUnusedKeyIndex);\r\n            return {\r\n                unusedDerivedKeys: [nextUnusedDerivedKeys.find(Boolean)],\r\n            };\r\n        }\r\n        return {\r\n            unusedDerivedKeys: [unusedDerivedKeys.find(Boolean)],\r\n        };\r\n    }\r\n    async login(profileId, password) {\r\n        try {\r\n            const bip39Mnemonic = await Persist.login(profileId, password);\r\n            await Persist.init(profileId);\r\n            await this._initWallet(bip39Mnemonic);\r\n            return { profile: profileId };\r\n        }\r\n        catch (error) {\r\n            throw error;\r\n        }\r\n    }\r\n    async createProfile(bip39Mnemonic, password) {\r\n        const cryptedText = AES.encrypt(bip39Mnemonic, password).toString();\r\n        const profileName = faker.name.firstName();\r\n        localStorage.setItem('currentprofile', profileName);\r\n        try {\r\n            await Persist.createProfile(cryptedText, profileName);\r\n            return { profile: profileName };\r\n        }\r\n        catch (error) {\r\n            throw error;\r\n        }\r\n    }\r\n    async updateProfileName(currentProfileName, newProfileName) {\r\n        try {\r\n            await Persist.updateProfileName(currentProfileName, newProfileName);\r\n            return { profile: newProfileName };\r\n        }\r\n        catch (error) {\r\n            throw error;\r\n        }\r\n    }\r\n    async getProfiles() {\r\n        return { profiles: await Persist.getProfiles() };\r\n    }\r\n    async logout() {\r\n        return await Persist.destroy();\r\n    }\r\n    async runScript() {\r\n        // const keys: object[] = await this._getKeys([\r\n        //   'mk4z9XdCQ9uUks1AZgUf8R28kVmESp623P',\r\n        // ]);\r\n        // mk4z9XdCQ9uUks1AZgUf8R28kVmESp623P;\r\n        // Persist.runScript();\r\n        // await Persist.upsertTransactions([\r\n        //   {\r\n        //     txId:\r\n        //       '98e4c42f69876d8e37fe5a47ee6a62f5bb48a730988b209de0cdd3e6c1b06cd4',\r\n        //     confirmed: false,\r\n        //   },\r\n        // ]);\r\n    }\r\n}\r\nexport default new Wallet();\r\n//# sourceMappingURL=Wallet.js.map","references":["/home/xkn/Desktop/integration/nipkow/lib/nipkow-sdk/node_modules/bitcoinjs-lib/types/index.d.ts","/home/xkn/Desktop/integration/nipkow/lib/nipkow-sdk/node_modules/@types/crypto-js/aes/index.d.ts","/home/xkn/Desktop/integration/nipkow/lib/nipkow-sdk/node_modules/coinselect/index.js","/home/xkn/Desktop/integration/nipkow/lib/nipkow-sdk/node_modules/@types/faker/index.d.ts","/home/xkn/Desktop/integration/nipkow/lib/nipkow-sdk/node_modules/@types/bip38/index.d.ts","/home/xkn/Desktop/integration/nipkow/lib/nipkow-sdk/node_modules/bip39/types/index.d.ts","/home/xkn/Desktop/integration/nipkow/lib/nipkow-sdk/node_modules/@types/lodash/index.d.ts","/home/xkn/Desktop/integration/nipkow/lib/nipkow-sdk/src/Persist.ts","/home/xkn/Desktop/integration/nipkow/lib/nipkow-sdk/src/constants/derivationPaths.ts","/home/xkn/Desktop/integration/nipkow/lib/nipkow-sdk/src/constants/network.ts","/home/xkn/Desktop/integration/nipkow/lib/nipkow-sdk/src/AddressAPI.ts","/home/xkn/Desktop/integration/nipkow/lib/nipkow-sdk/src/TransactionAPI.ts","/home/xkn/Desktop/integration/nipkow/lib/nipkow-sdk/src/ChainAPI.ts"],"map":"{\"version\":3,\"file\":\"Wallet.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../src/Wallet.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/xkn/Desktop/integration/nipkow/lib/nipkow-sdk/Wallet.d.ts","writeByteOrderMark":false,"text":"/// <reference types=\"node\" />\r\n/// <reference types=\"pouchdb-core\" />\r\nimport { Network } from 'bitcoinjs-lib';\r\ndeclare class Wallet {\r\n    _initWallet(bip39Mnemonic: string, password?: string): Promise<void>;\r\n    _mnemonicToSeedSync(bip39Mnemonic: string, password?: string): Buffer;\r\n    _getBIP32RootKeyFromSeed(seed: Buffer, network?: Network): string;\r\n    _getBIP32ExtendedKey(path: string, bip32RootKey: string): string;\r\n    _generateDerivedAddress(bip32ExtendedKey: string, index: number, useBip38?: boolean, bip38password?: string, useHardenedAddresses?: boolean): {\r\n        indexText: string;\r\n        address: string;\r\n    };\r\n    _getPrivKey(bip32ExtendedKey: string, index: number, useBip38?: boolean, bip38password?: string, useHardenedAddresses?: boolean): {\r\n        privkey: string;\r\n    };\r\n    _generateDerivedKeys(bip32ExtendedKey: string, indexStart: number, count: number, useBip38: boolean, bip38password?: string, useHardenedAddresses?: boolean): Promise<{\r\n        derivedKeys: {\r\n            isUsed: boolean;\r\n            indexText: string;\r\n            address: string;\r\n        }[];\r\n    }>;\r\n    _getAddressesFromKeys(derivedKeys: any[]): any[];\r\n    getTransaction(txid: string): Promise<any>;\r\n    _countOfUnusedKeys(keys: any[]): any;\r\n    getTransactions(options?: {\r\n        startkey?: string;\r\n        limit?: number;\r\n        pageNo?: number;\r\n        diff?: boolean;\r\n    }): Promise<{\r\n        nextTransactionCursor: any;\r\n        transactions: any;\r\n    } | {\r\n        transactions: {\r\n            txId: any;\r\n            inputs: any;\r\n            outputs: any;\r\n            confirmations?: number | undefined;\r\n        }[];\r\n    }>;\r\n    _getTransactions(txIds: string[]): Promise<{\r\n        txs: any[];\r\n    }>;\r\n    _getOutputs(derivedKeys: any[], prevOutputs?: any[], prevDiffOutputs?: any[], prevKeys?: any[]): Promise<any>;\r\n    _getOutputsByAddresses(keys: any[], prevOutputs?: any[], nextCursor?: number): Promise<any>;\r\n    _getDiffOutputs(outputs: any): Promise<any[]>;\r\n    updateconfirmations(): Promise<void>;\r\n    updateUnconfirmedTransactions(): Promise<void>;\r\n    _getChangeAddress(): Promise<any>;\r\n    _getKeys(addresses: string[]): Promise<object[]>;\r\n    _createSendTransaction(utxos: any[], targets: any[], feeRate: number): Promise<void>;\r\n    createSendTransaction(receiverAddress: string, amountInSatoshi: number, feeRate: number): Promise<void>;\r\n    getTransactionFee(receiverAddress: string, amountInSatoshi: number, feeRate: number): Promise<any>;\r\n    getBalance(): Promise<{\r\n        balance: any;\r\n    }>;\r\n    generateMnemonic(strength?: number, rng?: (size: number) => Buffer, wordlist?: string[]): string;\r\n    getUsedDerivedKeys(): Promise<{\r\n        usedDerivedKeys: {\r\n            address: string;\r\n            incomingBalance: number;\r\n            outgoingBalance: number;\r\n            currentBalance: number;\r\n            lastTransaction: any;\r\n        }[];\r\n    }>;\r\n    getUnusedDerivedKeys(options?: {\r\n        currentUnusedKeyIndex?: string;\r\n    }): Promise<{\r\n        unusedDerivedKeys: any[];\r\n    }>;\r\n    login(profileId: string, password: string): Promise<{\r\n        profile: string;\r\n    }>;\r\n    createProfile(bip39Mnemonic: string, password: string): Promise<{\r\n        profile: string;\r\n    }>;\r\n    updateProfileName(currentProfileName: string, newProfileName: string): Promise<{\r\n        profile: string;\r\n    }>;\r\n    getProfiles(): Promise<{\r\n        profiles: any;\r\n    }>;\r\n    logout(): Promise<boolean>;\r\n    runScript(): Promise<void>;\r\n}\r\ndeclare const _default: Wallet;\r\nexport default _default;\r\n"}}
